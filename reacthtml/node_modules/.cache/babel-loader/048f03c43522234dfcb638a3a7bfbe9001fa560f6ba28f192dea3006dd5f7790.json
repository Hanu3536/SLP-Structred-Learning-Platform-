{"ast":null,"code":"import { makeCamelCaseArray, makeCamelCase } from './Utils';\nfunction getBoundingBox(geometry) {\n  if (!geometry) return undefined;\n  return makeCamelCase(geometry.BoundingBox);\n}\nfunction getPolygon(geometry) {\n  if (!geometry) return undefined;\n  return makeCamelCaseArray(geometry.Polygon);\n}\n/**\n * Organizes blocks from Rekognition API to each of the categories and and structures\n * their data accordingly.\n * @param {Textract.BlockList} source - Array containing blocks returned from Textract API.\n * @return {IdentifyTextOutput} -  Object that categorizes each block and its information.\n */\nexport function categorizeRekognitionBlocks(blocks) {\n  // Skeleton IdentifyText API response. We will populate it as we iterate through blocks.\n  var response = {\n    text: {\n      fullText: '',\n      words: [],\n      lines: [],\n      linesDetailed: []\n    }\n  };\n  // We categorize each block by running a forEach loop through them.\n  blocks.forEach(function (block) {\n    switch (block.Type) {\n      case 'LINE':\n        response.text.lines.push(block.DetectedText);\n        response.text.linesDetailed.push({\n          text: block.DetectedText,\n          polygon: getPolygon(block.Geometry),\n          boundingBox: getBoundingBox(block.Geometry),\n          page: null\n        });\n        break;\n      case 'WORD':\n        response.text.fullText += block.DetectedText + ' ';\n        response.text.words.push({\n          text: block.DetectedText,\n          polygon: getPolygon(block.Geometry),\n          boundingBox: getBoundingBox(block.Geometry)\n        });\n        break;\n    }\n  });\n  // remove trailing space of fullText\n  response.text.fullText = response.text.fullText.substr(0, response.text.fullText.length - 1);\n  return response;\n}\n/**\n * Organizes blocks from Textract API to each of the categories and and structures\n * their data accordingly.\n * @param {Textract.BlockList} source - Array containing blocks returned from Textract API.\n * @return {IdentifyTextOutput} -  Object that categorizes each block and its information.\n */\nexport function categorizeTextractBlocks(blocks) {\n  // Skeleton IdentifyText API response. We will populate it as we iterate through blocks.\n  var response = {\n    text: {\n      fullText: '',\n      words: [],\n      lines: [],\n      linesDetailed: []\n    }\n  };\n  // if blocks is an empty array, ie. textract did not detect anything, return empty response.\n  if (blocks.length === 0) return response;\n  /**\n   * We categorize each of the blocks by running a forEach loop through them.\n   *\n   * For complex structures such as Tables and KeyValue, we need to trasverse through their children. To do so,\n   * we will post-process them after the for each loop. We do this by storing table and keyvalues in arrays and\n   * mapping other blocks in `blockMap` (id to block) so we can reference them easily later.\n   *\n   * Note that we do not map `WORD` and `TABLE` in `blockMap` because they will not be referenced by any other\n   * block except the Page block.\n   */\n  var tableBlocks = Array();\n  var keyValueBlocks = Array();\n  var blockMap = {};\n  blocks.forEach(function (block) {\n    switch (block.BlockType) {\n      case 'LINE':\n        response.text.lines.push(block.Text);\n        response.text.linesDetailed.push({\n          text: block.Text,\n          polygon: getPolygon(block.Geometry),\n          boundingBox: getBoundingBox(block.Geometry),\n          page: block.Page\n        });\n        break;\n      case 'WORD':\n        response.text.fullText += block.Text + ' ';\n        response.text.words.push({\n          text: block.Text,\n          polygon: getPolygon(block.Geometry),\n          boundingBox: getBoundingBox(block.Geometry)\n        });\n        blockMap[block.Id] = block;\n        break;\n      case 'SELECTION_ELEMENT':\n        var selectionStatus = block.SelectionStatus === 'SELECTED' ? true : false;\n        if (!response.text.selections) response.text.selections = [];\n        response.text.selections.push({\n          selected: selectionStatus,\n          polygon: getPolygon(block.Geometry),\n          boundingBox: getBoundingBox(block.Geometry)\n        });\n        blockMap[block.Id] = block;\n        break;\n      case 'TABLE':\n        tableBlocks.push(block);\n        break;\n      case 'KEY_VALUE_SET':\n        keyValueBlocks.push(block);\n        blockMap[block.Id] = block;\n        break;\n      default:\n        blockMap[block.Id] = block;\n    }\n  });\n  // remove trailing space in fullText\n  response.text.fullText = response.text.fullText.substr(0, response.text.fullText.length - 1);\n  // Post-process complex structures if they exist.\n  if (tableBlocks.length !== 0) {\n    var tableResponse_1 = Array();\n    tableBlocks.forEach(function (table) {\n      tableResponse_1.push(constructTable(table, blockMap));\n    });\n    response.text.tables = tableResponse_1;\n  }\n  if (keyValueBlocks.length !== 0) {\n    var keyValueResponse_1 = Array();\n    keyValueBlocks.forEach(function (keyValue) {\n      // We need the KeyValue blocks of EntityType = `KEY`, which has both key and value references.\n      if (keyValue.EntityTypes.indexOf('KEY') !== -1) {\n        keyValueResponse_1.push(constructKeyValue(keyValue, blockMap));\n      }\n    });\n    response.text.keyValues = keyValueResponse_1;\n  }\n  return response;\n}\n/**\n * Constructs a table object using data from its children cells.\n * @param {Textract.Block} table - Table block that has references (`Relationships`) to its cells\n * @param {[id: string]: Textract.Block} blockMap - Maps block Ids to blocks.\n */\nexport function constructTable(table, blockMap) {\n  var tableMatrix;\n  tableMatrix = [];\n  // visit each of the cell associated with the table's relationship.\n  table.Relationships.forEach(function (tableRelation) {\n    tableRelation.Ids.forEach(function (cellId) {\n      var cellBlock = blockMap[cellId];\n      var row = cellBlock.RowIndex - 1; // textract starts indexing at 1, so subtract it by 1.\n      var col = cellBlock.ColumnIndex - 1; // textract starts indexing at 1, so subtract it by 1.\n      // extract data contained inside the cell.\n      var content = extractContentsFromBlock(cellBlock, blockMap);\n      var cell = {\n        text: content.text,\n        boundingBox: getBoundingBox(cellBlock.Geometry),\n        polygon: getPolygon(cellBlock.Geometry),\n        selected: content.selected,\n        rowSpan: cellBlock.RowSpan,\n        columnSpan: cellBlock.ColumnSpan\n      };\n      if (!tableMatrix[row]) tableMatrix[row] = [];\n      tableMatrix[row][col] = cell;\n    });\n  });\n  var rowSize = tableMatrix.length;\n  var columnSize = tableMatrix[0].length;\n  // Note that we leave spanned cells undefined for distinction\n  return {\n    size: {\n      rows: rowSize,\n      columns: columnSize\n    },\n    table: tableMatrix,\n    boundingBox: getBoundingBox(table.Geometry),\n    polygon: getPolygon(table.Geometry)\n  };\n}\n/**\n * Constructs a key value object from its children key and value blocks.\n * @param {Textract.Block} KeyValue - KeyValue block that has references (`Relationships`) to its children.\n * @param {[id: string]: Textract.Block} blockMap - Maps block Ids to blocks.\n */\nexport function constructKeyValue(keyBlock, blockMap) {\n  var keyText = '';\n  var valueText = '';\n  var valueSelected;\n  keyBlock.Relationships.forEach(function (keyValueRelation) {\n    if (keyValueRelation.Type === 'CHILD') {\n      // relation refers to key\n      var contents = extractContentsFromBlock(keyBlock, blockMap);\n      keyText = contents.text;\n    } else if (keyValueRelation.Type === 'VALUE') {\n      // relation refers to value\n      keyValueRelation.Ids.forEach(function (valueId) {\n        var valueBlock = blockMap[valueId];\n        var contents = extractContentsFromBlock(valueBlock, blockMap);\n        valueText = contents.text;\n        if (contents.selected != null) valueSelected = contents.selected;\n      });\n    }\n  });\n  return {\n    key: keyText,\n    value: {\n      text: valueText,\n      selected: valueSelected\n    },\n    polygon: getPolygon(keyBlock.Geometry),\n    boundingBox: getBoundingBox(keyBlock.Geometry)\n  };\n}\n/**\n * Extracts text and selection from input block's children.\n * @param {Textract.Block}} block - Block that we want to extract contents from.\n * @param {[id: string]: Textract.Block} blockMap - Maps block Ids to blocks.\n */\nexport function extractContentsFromBlock(block, blockMap) {\n  var words = '';\n  var isSelected;\n  if (!block.Relationships) {\n    // some block might have no content\n    return {\n      text: '',\n      selected: undefined\n    };\n  }\n  block.Relationships.forEach(function (relation) {\n    relation.Ids.forEach(function (contentId) {\n      var contentBlock = blockMap[contentId];\n      if (contentBlock.BlockType === 'WORD') {\n        words += contentBlock.Text + ' ';\n      } else if (contentBlock.BlockType === 'SELECTION_ELEMENT') {\n        isSelected = contentBlock.SelectionStatus === 'SELECTED' ? true : false;\n      }\n    });\n  });\n  words = words.substr(0, words.length - 1); // remove trailing space.\n  return {\n    text: words,\n    selected: isSelected\n  };\n}","map":{"version":3,"names":["makeCamelCaseArray","makeCamelCase","getBoundingBox","geometry","undefined","BoundingBox","getPolygon","Polygon","categorizeRekognitionBlocks","blocks","response","text","fullText","words","lines","linesDetailed","forEach","block","Type","push","DetectedText","polygon","Geometry","boundingBox","page","substr","length","categorizeTextractBlocks","tableBlocks","Array","keyValueBlocks","blockMap","BlockType","Text","Page","Id","selectionStatus","SelectionStatus","selections","selected","tableResponse_1","table","constructTable","tables","keyValueResponse_1","keyValue","EntityTypes","indexOf","constructKeyValue","keyValues","tableMatrix","Relationships","tableRelation","Ids","cellId","cellBlock","row","RowIndex","col","ColumnIndex","content","extractContentsFromBlock","cell","rowSpan","RowSpan","columnSpan","ColumnSpan","rowSize","columnSize","size","rows","columns","keyBlock","keyText","valueText","valueSelected","keyValueRelation","contents","valueId","valueBlock","key","value","isSelected","relation","contentId","contentBlock"],"sources":["C:\\Study\\6805\\React\\reacthtml\\node_modules\\@aws-amplify\\predictions\\src\\Providers\\IdentifyTextUtils.ts"],"sourcesContent":["import * as Rekognition from 'aws-sdk/clients/rekognition';\nimport * as Textract from 'aws-sdk/clients/textract';\nimport {\n\tIdentifyTextOutput,\n\tTable,\n\tKeyValue,\n\tTableCell,\n\tContent,\n\tBoundingBox,\n\tPolygon,\n} from '../types';\nimport { makeCamelCaseArray, makeCamelCase } from './Utils';\n\nfunction getBoundingBox(\n\tgeometry: Rekognition.Geometry | Textract.Geometry\n): BoundingBox {\n\tif (!geometry) return undefined;\n\treturn makeCamelCase(geometry.BoundingBox);\n}\n\nfunction getPolygon(\n\tgeometry: Rekognition.Geometry | Textract.Geometry\n): Polygon {\n\tif (!geometry) return undefined;\n\treturn makeCamelCaseArray(geometry.Polygon);\n}\n\n/**\n * Organizes blocks from Rekognition API to each of the categories and and structures\n * their data accordingly.\n * @param {Textract.BlockList} source - Array containing blocks returned from Textract API.\n * @return {IdentifyTextOutput} -  Object that categorizes each block and its information.\n */\nexport function categorizeRekognitionBlocks(\n\tblocks: Rekognition.TextDetectionList\n): IdentifyTextOutput {\n\t// Skeleton IdentifyText API response. We will populate it as we iterate through blocks.\n\tconst response: IdentifyTextOutput = {\n\t\ttext: {\n\t\t\tfullText: '',\n\t\t\twords: [],\n\t\t\tlines: [],\n\t\t\tlinesDetailed: [],\n\t\t},\n\t};\n\t// We categorize each block by running a forEach loop through them.\n\tblocks.forEach(block => {\n\t\tswitch (block.Type) {\n\t\t\tcase 'LINE':\n\t\t\t\tresponse.text.lines.push(block.DetectedText);\n\t\t\t\tresponse.text.linesDetailed.push({\n\t\t\t\t\ttext: block.DetectedText,\n\t\t\t\t\tpolygon: getPolygon(block.Geometry),\n\t\t\t\t\tboundingBox: getBoundingBox(block.Geometry),\n\t\t\t\t\tpage: null, // rekognition doesn't have this info\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase 'WORD':\n\t\t\t\tresponse.text.fullText += block.DetectedText + ' ';\n\t\t\t\tresponse.text.words.push({\n\t\t\t\t\ttext: block.DetectedText,\n\t\t\t\t\tpolygon: getPolygon(block.Geometry),\n\t\t\t\t\tboundingBox: getBoundingBox(block.Geometry),\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t}\n\t});\n\t// remove trailing space of fullText\n\tresponse.text.fullText = response.text.fullText.substr(\n\t\t0,\n\t\tresponse.text.fullText.length - 1\n\t);\n\treturn response;\n}\n\n/**\n * Organizes blocks from Textract API to each of the categories and and structures\n * their data accordingly.\n * @param {Textract.BlockList} source - Array containing blocks returned from Textract API.\n * @return {IdentifyTextOutput} -  Object that categorizes each block and its information.\n */\nexport function categorizeTextractBlocks(\n\tblocks: Textract.BlockList\n): IdentifyTextOutput {\n\t// Skeleton IdentifyText API response. We will populate it as we iterate through blocks.\n\tconst response: IdentifyTextOutput = {\n\t\ttext: {\n\t\t\tfullText: '',\n\t\t\twords: [],\n\t\t\tlines: [],\n\t\t\tlinesDetailed: [],\n\t\t},\n\t};\n\t// if blocks is an empty array, ie. textract did not detect anything, return empty response.\n\tif (blocks.length === 0) return response;\n\t/**\n\t * We categorize each of the blocks by running a forEach loop through them.\n\t *\n\t * For complex structures such as Tables and KeyValue, we need to trasverse through their children. To do so,\n\t * we will post-process them after the for each loop. We do this by storing table and keyvalues in arrays and\n\t * mapping other blocks in `blockMap` (id to block) so we can reference them easily later.\n\t *\n\t * Note that we do not map `WORD` and `TABLE` in `blockMap` because they will not be referenced by any other\n\t * block except the Page block.\n\t */\n\tconst tableBlocks: Textract.BlockList = Array();\n\tconst keyValueBlocks: Textract.BlockList = Array();\n\tconst blockMap: { [id: string]: Textract.Block } = {};\n\n\tblocks.forEach(block => {\n\t\tswitch (block.BlockType) {\n\t\t\tcase 'LINE':\n\t\t\t\tresponse.text.lines.push(block.Text);\n\t\t\t\tresponse.text.linesDetailed.push({\n\t\t\t\t\ttext: block.Text,\n\t\t\t\t\tpolygon: getPolygon(block.Geometry),\n\t\t\t\t\tboundingBox: getBoundingBox(block.Geometry),\n\t\t\t\t\tpage: block.Page,\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase 'WORD':\n\t\t\t\tresponse.text.fullText += block.Text + ' ';\n\t\t\t\tresponse.text.words.push({\n\t\t\t\t\ttext: block.Text,\n\t\t\t\t\tpolygon: getPolygon(block.Geometry),\n\t\t\t\t\tboundingBox: getBoundingBox(block.Geometry),\n\t\t\t\t});\n\t\t\t\tblockMap[block.Id] = block;\n\t\t\t\tbreak;\n\t\t\tcase 'SELECTION_ELEMENT':\n\t\t\t\tconst selectionStatus =\n\t\t\t\t\tblock.SelectionStatus === 'SELECTED' ? true : false;\n\t\t\t\tif (!response.text.selections) response.text.selections = [];\n\t\t\t\tresponse.text.selections.push({\n\t\t\t\t\tselected: selectionStatus,\n\t\t\t\t\tpolygon: getPolygon(block.Geometry),\n\t\t\t\t\tboundingBox: getBoundingBox(block.Geometry),\n\t\t\t\t});\n\t\t\t\tblockMap[block.Id] = block;\n\t\t\t\tbreak;\n\t\t\tcase 'TABLE':\n\t\t\t\ttableBlocks.push(block);\n\t\t\t\tbreak;\n\t\t\tcase 'KEY_VALUE_SET':\n\t\t\t\tkeyValueBlocks.push(block);\n\t\t\t\tblockMap[block.Id] = block;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tblockMap[block.Id] = block;\n\t\t}\n\t});\n\t// remove trailing space in fullText\n\tresponse.text.fullText = response.text.fullText.substr(\n\t\t0,\n\t\tresponse.text.fullText.length - 1\n\t);\n\n\t// Post-process complex structures if they exist.\n\tif (tableBlocks.length !== 0) {\n\t\tconst tableResponse: Table[] = Array();\n\t\ttableBlocks.forEach(table => {\n\t\t\ttableResponse.push(constructTable(table, blockMap));\n\t\t});\n\t\tresponse.text.tables = tableResponse;\n\t}\n\tif (keyValueBlocks.length !== 0) {\n\t\tconst keyValueResponse: KeyValue[] = Array();\n\t\tkeyValueBlocks.forEach(keyValue => {\n\t\t\t// We need the KeyValue blocks of EntityType = `KEY`, which has both key and value references.\n\t\t\tif (keyValue.EntityTypes.indexOf('KEY') !== -1) {\n\t\t\t\tkeyValueResponse.push(constructKeyValue(keyValue, blockMap));\n\t\t\t}\n\t\t});\n\t\tresponse.text.keyValues = keyValueResponse;\n\t}\n\treturn response;\n}\n\n/**\n * Constructs a table object using data from its children cells.\n * @param {Textract.Block} table - Table block that has references (`Relationships`) to its cells\n * @param {[id: string]: Textract.Block} blockMap - Maps block Ids to blocks.\n */\nexport function constructTable(\n\ttable: Textract.Block,\n\tblockMap: { [key: string]: Textract.Block }\n): Table {\n\tlet tableMatrix: TableCell[][];\n\ttableMatrix = [];\n\t// visit each of the cell associated with the table's relationship.\n\ttable.Relationships.forEach(tableRelation => {\n\t\ttableRelation.Ids.forEach(cellId => {\n\t\t\tconst cellBlock: Textract.Block = blockMap[cellId];\n\t\t\tconst row = cellBlock.RowIndex - 1; // textract starts indexing at 1, so subtract it by 1.\n\t\t\tconst col = cellBlock.ColumnIndex - 1; // textract starts indexing at 1, so subtract it by 1.\n\t\t\t// extract data contained inside the cell.\n\t\t\tconst content = extractContentsFromBlock(cellBlock, blockMap);\n\t\t\tconst cell: TableCell = {\n\t\t\t\ttext: content.text,\n\t\t\t\tboundingBox: getBoundingBox(cellBlock.Geometry),\n\t\t\t\tpolygon: getPolygon(cellBlock.Geometry),\n\t\t\t\tselected: content.selected,\n\t\t\t\trowSpan: cellBlock.RowSpan,\n\t\t\t\tcolumnSpan: cellBlock.ColumnSpan,\n\t\t\t};\n\t\t\tif (!tableMatrix[row]) tableMatrix[row] = [];\n\t\t\ttableMatrix[row][col] = cell;\n\t\t});\n\t});\n\tconst rowSize = tableMatrix.length;\n\tconst columnSize = tableMatrix[0].length;\n\t// Note that we leave spanned cells undefined for distinction\n\treturn {\n\t\tsize: { rows: rowSize, columns: columnSize },\n\t\ttable: tableMatrix,\n\t\tboundingBox: getBoundingBox(table.Geometry),\n\t\tpolygon: getPolygon(table.Geometry),\n\t};\n}\n\n/**\n * Constructs a key value object from its children key and value blocks.\n * @param {Textract.Block} KeyValue - KeyValue block that has references (`Relationships`) to its children.\n * @param {[id: string]: Textract.Block} blockMap - Maps block Ids to blocks.\n */\nexport function constructKeyValue(\n\tkeyBlock: Textract.Block,\n\tblockMap: { [key: string]: Textract.Block }\n): KeyValue {\n\tlet keyText: string = '';\n\tlet valueText: string = '';\n\tlet valueSelected: boolean;\n\tkeyBlock.Relationships.forEach(keyValueRelation => {\n\t\tif (keyValueRelation.Type === 'CHILD') {\n\t\t\t// relation refers to key\n\t\t\tconst contents = extractContentsFromBlock(keyBlock, blockMap);\n\t\t\tkeyText = contents.text;\n\t\t} else if (keyValueRelation.Type === 'VALUE') {\n\t\t\t// relation refers to value\n\t\t\tkeyValueRelation.Ids.forEach(valueId => {\n\t\t\t\tconst valueBlock = blockMap[valueId];\n\t\t\t\tconst contents = extractContentsFromBlock(valueBlock, blockMap);\n\t\t\t\tvalueText = contents.text;\n\t\t\t\tif (contents.selected != null) valueSelected = contents.selected;\n\t\t\t});\n\t\t}\n\t});\n\treturn {\n\t\tkey: keyText,\n\t\tvalue: { text: valueText, selected: valueSelected },\n\t\tpolygon: getPolygon(keyBlock.Geometry),\n\t\tboundingBox: getBoundingBox(keyBlock.Geometry),\n\t};\n}\n\n/**\n * Extracts text and selection from input block's children.\n * @param {Textract.Block}} block - Block that we want to extract contents from.\n * @param {[id: string]: Textract.Block} blockMap - Maps block Ids to blocks.\n */\nexport function extractContentsFromBlock(\n\tblock: Textract.Block,\n\tblockMap: { [id: string]: Textract.Block }\n): Content {\n\tlet words: string = '';\n\tlet isSelected: boolean;\n\n\tif (!block.Relationships) {\n\t\t// some block might have no content\n\t\treturn { text: '', selected: undefined };\n\t}\n\tblock.Relationships.forEach(relation => {\n\t\trelation.Ids.forEach(contentId => {\n\t\t\tconst contentBlock = blockMap[contentId];\n\t\t\tif (contentBlock.BlockType === 'WORD') {\n\t\t\t\twords += contentBlock.Text + ' ';\n\t\t\t} else if (contentBlock.BlockType === 'SELECTION_ELEMENT') {\n\t\t\t\tisSelected = contentBlock.SelectionStatus === 'SELECTED' ? true : false;\n\t\t\t}\n\t\t});\n\t});\n\n\twords = words.substr(0, words.length - 1); // remove trailing space.\n\treturn { text: words, selected: isSelected };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}