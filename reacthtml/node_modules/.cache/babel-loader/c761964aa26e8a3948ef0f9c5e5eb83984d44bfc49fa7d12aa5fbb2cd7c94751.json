{"ast":null,"code":"/*\n * Copyright 2017-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n *     http://aws.amazon.com/apache2.0/\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nimport { isUsernamePasswordOpts, isCognitoHostedOpts, isFederatedSignInOptions, isFederatedSignInOptionsCustom } from './types';\nimport { AWS, ConsoleLogger as Logger, Constants, Hub, JS, Parser, Credentials, StorageHelper } from '@aws-amplify/core';\nimport { CookieStorage, CognitoUserPool, AuthenticationDetails, CognitoUser, CognitoUserSession, CognitoUserAttribute, CognitoIdToken, CognitoRefreshToken, CognitoAccessToken } from 'amazon-cognito-identity-js';\nimport { parse } from 'url';\nimport OAuth from './OAuth/OAuth';\nimport { default as urlListener } from './urlListener';\nimport { AuthError, NoUserPoolError } from './Errors';\nimport { AuthErrorTypes } from './types/Auth';\nvar logger = new Logger('AuthClass');\nvar USER_ADMIN_SCOPE = 'aws.cognito.signin.user.admin';\nvar AMPLIFY_SYMBOL = typeof Symbol !== 'undefined' && typeof Symbol.for === 'function' ? Symbol.for('amplify_default') : '@@amplify_default';\nvar dispatchAuthEvent = function (event, data, message) {\n  Hub.dispatch('auth', {\n    event: event,\n    data: data,\n    message: message\n  }, 'Auth', AMPLIFY_SYMBOL);\n};\nexport var CognitoHostedUIIdentityProvider;\n(function (CognitoHostedUIIdentityProvider) {\n  CognitoHostedUIIdentityProvider[\"Cognito\"] = \"COGNITO\";\n  CognitoHostedUIIdentityProvider[\"Google\"] = \"Google\";\n  CognitoHostedUIIdentityProvider[\"Facebook\"] = \"Facebook\";\n  CognitoHostedUIIdentityProvider[\"Amazon\"] = \"LoginWithAmazon\";\n})(CognitoHostedUIIdentityProvider || (CognitoHostedUIIdentityProvider = {}));\n/**\n * Provide authentication steps\n */\nvar AuthClass = /** @class */function () {\n  /**\n   * Initialize Auth with AWS configurations\n   * @param {Object} config - Configuration of the Auth\n   */\n  function AuthClass(config) {\n    var _this = this;\n    this.userPool = null;\n    this.user = null;\n    this.configure(config);\n    this.currentUserCredentials = this.currentUserCredentials.bind(this);\n    if (AWS.config) {\n      AWS.config.update({\n        customUserAgent: Constants.userAgent\n      });\n    } else {\n      logger.warn('No AWS.config');\n    }\n    Hub.listen('auth', function (_a) {\n      var payload = _a.payload;\n      var event = payload.event;\n      switch (event) {\n        case 'signIn':\n          _this._storage.setItem('amplify-signin-with-hostedUI', 'false');\n          break;\n        case 'signOut':\n          _this._storage.removeItem('amplify-signin-with-hostedUI');\n          break;\n        case 'cognitoHostedUI':\n          _this._storage.setItem('amplify-signin-with-hostedUI', 'true');\n          break;\n      }\n    });\n  }\n  AuthClass.prototype.getModuleName = function () {\n    return 'Auth';\n  };\n  AuthClass.prototype.configure = function (config) {\n    var _this = this;\n    if (!config) return this._config || {};\n    logger.debug('configure Auth');\n    var conf = Object.assign({}, this._config, Parser.parseMobilehubConfig(config).Auth, config);\n    this._config = conf;\n    var _a = this._config,\n      userPoolId = _a.userPoolId,\n      userPoolWebClientId = _a.userPoolWebClientId,\n      cookieStorage = _a.cookieStorage,\n      oauth = _a.oauth,\n      region = _a.region,\n      identityPoolId = _a.identityPoolId,\n      mandatorySignIn = _a.mandatorySignIn,\n      refreshHandlers = _a.refreshHandlers,\n      identityPoolRegion = _a.identityPoolRegion,\n      clientMetadata = _a.clientMetadata;\n    if (!this._config.storage) {\n      // backward compatbility\n      if (cookieStorage) this._storage = new CookieStorage(cookieStorage);else {\n        this._storage = new StorageHelper().getStorage();\n      }\n    } else {\n      if (!this._isValidAuthStorage(this._config.storage)) {\n        logger.error('The storage in the Auth config is not valid!');\n        throw new Error('Empty storage object');\n      }\n      this._storage = this._config.storage;\n    }\n    this._storageSync = Promise.resolve();\n    if (typeof this._storage['sync'] === 'function') {\n      this._storageSync = this._storage['sync']();\n    }\n    if (userPoolId) {\n      var userPoolData = {\n        UserPoolId: userPoolId,\n        ClientId: userPoolWebClientId\n      };\n      userPoolData.Storage = this._storage;\n      this.userPool = new CognitoUserPool(userPoolData);\n    }\n    Credentials.configure({\n      mandatorySignIn: mandatorySignIn,\n      region: identityPoolRegion || region,\n      userPoolId: userPoolId,\n      identityPoolId: identityPoolId,\n      refreshHandlers: refreshHandlers,\n      storage: this._storage\n    });\n    // initiailize cognitoauth client if hosted ui options provided\n    // to keep backward compatibility:\n    var cognitoHostedUIConfig = oauth ? isCognitoHostedOpts(this._config.oauth) ? oauth : oauth.awsCognito : undefined;\n    if (cognitoHostedUIConfig) {\n      var cognitoAuthParams = Object.assign({\n        cognitoClientId: userPoolWebClientId,\n        UserPoolId: userPoolId,\n        domain: cognitoHostedUIConfig['domain'],\n        scopes: cognitoHostedUIConfig['scope'],\n        redirectSignIn: cognitoHostedUIConfig['redirectSignIn'],\n        redirectSignOut: cognitoHostedUIConfig['redirectSignOut'],\n        responseType: cognitoHostedUIConfig['responseType'],\n        Storage: this._storage,\n        urlOpener: cognitoHostedUIConfig['urlOpener'],\n        clientMetadata: clientMetadata\n      }, cognitoHostedUIConfig['options']);\n      this._oAuthHandler = new OAuth({\n        scopes: cognitoAuthParams.scopes,\n        config: cognitoAuthParams,\n        cognitoClientId: cognitoAuthParams.cognitoClientId\n      });\n      // **NOTE** - Remove this in a future major release as it is a breaking change\n      urlListener(function (_a) {\n        var url = _a.url;\n        _this._handleAuthResponse(url);\n      });\n    }\n    dispatchAuthEvent('configured', null, \"The Auth category has been configured successfully\");\n    return this._config;\n  };\n  /**\n   * Sign up with username, password and other attrbutes like phone, email\n   * @param {String | object} params - The user attirbutes used for signin\n   * @param {String[]} restOfAttrs - for the backward compatability\n   * @return - A promise resolves callback data if success\n   */\n  AuthClass.prototype.signUp = function (params) {\n    var _this = this;\n    var restOfAttrs = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      restOfAttrs[_i - 1] = arguments[_i];\n    }\n    if (!this.userPool) {\n      return this.rejectNoUserPool();\n    }\n    var username = null;\n    var password = null;\n    var attributes = [];\n    var validationData = null;\n    var clientMetadata;\n    if (params && typeof params === 'string') {\n      username = params;\n      password = restOfAttrs ? restOfAttrs[0] : null;\n      var email = restOfAttrs ? restOfAttrs[1] : null;\n      var phone_number = restOfAttrs ? restOfAttrs[2] : null;\n      if (email) attributes.push({\n        Name: 'email',\n        Value: email\n      });\n      if (phone_number) attributes.push({\n        Name: 'phone_number',\n        Value: phone_number\n      });\n    } else if (params && typeof params === 'object') {\n      username = params['username'];\n      password = params['password'];\n      if (params && params.clientMetadata) {\n        clientMetadata = params.clientMetadata;\n      } else if (this._config.clientMetadata) {\n        clientMetadata = this._config.clientMetadata;\n      }\n      var attrs_1 = params['attributes'];\n      if (attrs_1) {\n        Object.keys(attrs_1).map(function (key) {\n          var ele = {\n            Name: key,\n            Value: attrs_1[key]\n          };\n          attributes.push(ele);\n        });\n      }\n      validationData = params['validationData'] || null;\n    } else {\n      return this.rejectAuthError(AuthErrorTypes.SignUpError);\n    }\n    if (!username) {\n      return this.rejectAuthError(AuthErrorTypes.EmptyUsername);\n    }\n    if (!password) {\n      return this.rejectAuthError(AuthErrorTypes.EmptyPassword);\n    }\n    logger.debug('signUp attrs:', attributes);\n    logger.debug('signUp validation data:', validationData);\n    return new Promise(function (resolve, reject) {\n      _this.userPool.signUp(username, password, attributes, validationData, function (err, data) {\n        if (err) {\n          dispatchAuthEvent('signUp_failure', err, username + \" failed to signup\");\n          reject(err);\n        } else {\n          dispatchAuthEvent('signUp', data, username + \" has signed up successfully\");\n          resolve(data);\n        }\n      }, clientMetadata);\n    });\n  };\n  /**\n   * Send the verfication code to confirm sign up\n   * @param {String} username - The username to be confirmed\n   * @param {String} code - The verification code\n   * @param {ConfirmSignUpOptions} options - other options for confirm signup\n   * @return - A promise resolves callback data if success\n   */\n  AuthClass.prototype.confirmSignUp = function (username, code, options) {\n    if (!this.userPool) {\n      return this.rejectNoUserPool();\n    }\n    if (!username) {\n      return this.rejectAuthError(AuthErrorTypes.EmptyUsername);\n    }\n    if (!code) {\n      return this.rejectAuthError(AuthErrorTypes.EmptyCode);\n    }\n    var user = this.createCognitoUser(username);\n    var forceAliasCreation = options && typeof options.forceAliasCreation === 'boolean' ? options.forceAliasCreation : true;\n    var clientMetadata;\n    if (options && options.clientMetadata) {\n      clientMetadata = options.clientMetadata;\n    } else if (this._config.clientMetadata) {\n      clientMetadata = this._config.clientMetadata;\n    }\n    return new Promise(function (resolve, reject) {\n      user.confirmRegistration(code, forceAliasCreation, function (err, data) {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(data);\n        }\n      }, clientMetadata);\n    });\n  };\n  /**\n   * Resend the verification code\n   * @param {String} username - The username to be confirmed\n   * @param {ClientMetadata} clientMetadata - Metadata to be passed to Cognito Lambda triggers\n   * @return - A promise resolves data if success\n   */\n  AuthClass.prototype.resendSignUp = function (username, clientMetadata) {\n    if (clientMetadata === void 0) {\n      clientMetadata = this._config.clientMetadata;\n    }\n    if (!this.userPool) {\n      return this.rejectNoUserPool();\n    }\n    if (!username) {\n      return this.rejectAuthError(AuthErrorTypes.EmptyUsername);\n    }\n    var user = this.createCognitoUser(username);\n    return new Promise(function (resolve, reject) {\n      user.resendConfirmationCode(function (err, data) {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(data);\n        }\n      }, clientMetadata);\n    });\n  };\n  /**\n   * Sign in\n   * @param {String | SignInOpts} usernameOrSignInOpts - The username to be signed in or the sign in options\n   * @param {String} password - The password of the username\n   * @return - A promise resolves the CognitoUser\n   */\n  AuthClass.prototype.signIn = function (usernameOrSignInOpts, pw, clientMetadata) {\n    if (clientMetadata === void 0) {\n      clientMetadata = this._config.clientMetadata;\n    }\n    if (!this.userPool) {\n      return this.rejectNoUserPool();\n    }\n    var username = null;\n    var password = null;\n    var validationData = {};\n    // for backward compatibility\n    if (typeof usernameOrSignInOpts === 'string') {\n      username = usernameOrSignInOpts;\n      password = pw;\n    } else if (isUsernamePasswordOpts(usernameOrSignInOpts)) {\n      if (typeof pw !== 'undefined') {\n        logger.warn('The password should be defined under the first parameter object!');\n      }\n      username = usernameOrSignInOpts.username;\n      password = usernameOrSignInOpts.password;\n      validationData = usernameOrSignInOpts.validationData;\n    } else {\n      return this.rejectAuthError(AuthErrorTypes.InvalidUsername);\n    }\n    if (!username) {\n      return this.rejectAuthError(AuthErrorTypes.EmptyUsername);\n    }\n    var authDetails = new AuthenticationDetails({\n      Username: username,\n      Password: password,\n      ValidationData: validationData,\n      ClientMetadata: clientMetadata\n    });\n    if (password) {\n      return this.signInWithPassword(authDetails);\n    } else {\n      return this.signInWithoutPassword(authDetails);\n    }\n  };\n  /**\n   * Return an object with the authentication callbacks\n   * @param {CognitoUser} user - the cognito user object\n   * @param {} resolve - function called when resolving the current step\n   * @param {} reject - function called when rejecting the current step\n   * @return - an object with the callback methods for user authentication\n   */\n  AuthClass.prototype.authCallbacks = function (user, resolve, reject) {\n    var _this = this;\n    var that = this;\n    return {\n      onSuccess: function (session) {\n        return __awaiter(_this, void 0, void 0, function () {\n          var cred, e_1, currentUser, e_2;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                logger.debug(session);\n                delete user['challengeName'];\n                delete user['challengeParam'];\n                _a.label = 1;\n              case 1:\n                _a.trys.push([1, 4, 5, 9]);\n                return [4 /*yield*/, Credentials.clear()];\n              case 2:\n                _a.sent();\n                return [4 /*yield*/, Credentials.set(session, 'session')];\n              case 3:\n                cred = _a.sent();\n                logger.debug('succeed to get cognito credentials', cred);\n                return [3 /*break*/, 9];\n              case 4:\n                e_1 = _a.sent();\n                logger.debug('cannot get cognito credentials', e_1);\n                return [3 /*break*/, 9];\n              case 5:\n                _a.trys.push([5, 7,, 8]);\n                return [4 /*yield*/, this.currentUserPoolUser()];\n              case 6:\n                currentUser = _a.sent();\n                that.user = currentUser;\n                dispatchAuthEvent('signIn', currentUser, \"A user \" + user.getUsername() + \" has been signed in\");\n                resolve(currentUser);\n                return [3 /*break*/, 8];\n              case 7:\n                e_2 = _a.sent();\n                logger.error('Failed to get the signed in user', e_2);\n                reject(e_2);\n                return [3 /*break*/, 8];\n              case 8:\n                return [7 /*endfinally*/];\n              case 9:\n                return [2 /*return*/];\n            }\n          });\n        });\n      },\n\n      onFailure: function (err) {\n        logger.debug('signIn failure', err);\n        dispatchAuthEvent('signIn_failure', err, user.getUsername() + \" failed to signin\");\n        reject(err);\n      },\n      customChallenge: function (challengeParam) {\n        logger.debug('signIn custom challenge answer required');\n        user['challengeName'] = 'CUSTOM_CHALLENGE';\n        user['challengeParam'] = challengeParam;\n        resolve(user);\n      },\n      mfaRequired: function (challengeName, challengeParam) {\n        logger.debug('signIn MFA required');\n        user['challengeName'] = challengeName;\n        user['challengeParam'] = challengeParam;\n        resolve(user);\n      },\n      mfaSetup: function (challengeName, challengeParam) {\n        logger.debug('signIn mfa setup', challengeName);\n        user['challengeName'] = challengeName;\n        user['challengeParam'] = challengeParam;\n        resolve(user);\n      },\n      newPasswordRequired: function (userAttributes, requiredAttributes) {\n        logger.debug('signIn new password');\n        user['challengeName'] = 'NEW_PASSWORD_REQUIRED';\n        user['challengeParam'] = {\n          userAttributes: userAttributes,\n          requiredAttributes: requiredAttributes\n        };\n        resolve(user);\n      },\n      totpRequired: function (challengeName, challengeParam) {\n        logger.debug('signIn totpRequired');\n        user['challengeName'] = challengeName;\n        user['challengeParam'] = challengeParam;\n        resolve(user);\n      },\n      selectMFAType: function (challengeName, challengeParam) {\n        logger.debug('signIn selectMFAType', challengeName);\n        user['challengeName'] = challengeName;\n        user['challengeParam'] = challengeParam;\n        resolve(user);\n      }\n    };\n  };\n  /**\n   * Sign in with a password\n   * @private\n   * @param {AuthenticationDetails} authDetails - the user sign in data\n   * @return - A promise resolves the CognitoUser object if success or mfa required\n   */\n  AuthClass.prototype.signInWithPassword = function (authDetails) {\n    var _this = this;\n    var user = this.createCognitoUser(authDetails.getUsername());\n    return new Promise(function (resolve, reject) {\n      user.authenticateUser(authDetails, _this.authCallbacks(user, resolve, reject));\n    });\n  };\n  /**\n   * Sign in without a password\n   * @private\n   * @param {AuthenticationDetails} authDetails - the user sign in data\n   * @return - A promise resolves the CognitoUser object if success or mfa required\n   */\n  AuthClass.prototype.signInWithoutPassword = function (authDetails) {\n    var _this = this;\n    var user = this.createCognitoUser(authDetails.getUsername());\n    user.setAuthenticationFlowType('CUSTOM_AUTH');\n    return new Promise(function (resolve, reject) {\n      user.initiateAuth(authDetails, _this.authCallbacks(user, resolve, reject));\n    });\n  };\n  /**\n   * get user current preferred mfa option\n   * this method doesn't work with totp, we need to deprecate it.\n   * @deprecated\n   * @param {CognitoUser} user - the current user\n   * @return - A promise resolves the current preferred mfa option if success\n   */\n  AuthClass.prototype.getMFAOptions = function (user) {\n    return new Promise(function (res, rej) {\n      user.getMFAOptions(function (err, mfaOptions) {\n        if (err) {\n          logger.debug('get MFA Options failed', err);\n          rej(err);\n          return;\n        }\n        logger.debug('get MFA options success', mfaOptions);\n        res(mfaOptions);\n        return;\n      });\n    });\n  };\n  /**\n   * get preferred mfa method\n   * @param {CognitoUser} user - the current cognito user\n   * @param {GetPreferredMFAOpts} params - options for getting the current user preferred MFA\n   */\n  AuthClass.prototype.getPreferredMFA = function (user, params) {\n    var that = this;\n    return new Promise(function (res, rej) {\n      var bypassCache = params ? params.bypassCache : false;\n      user.getUserData(function (err, data) {\n        if (err) {\n          logger.debug('getting preferred mfa failed', err);\n          rej(err);\n          return;\n        }\n        var mfaType = that._getMfaTypeFromUserData(data);\n        if (!mfaType) {\n          rej('invalid MFA Type');\n          return;\n        } else {\n          res(mfaType);\n          return;\n        }\n      }, {\n        bypassCache: bypassCache\n      });\n    });\n  };\n  AuthClass.prototype._getMfaTypeFromUserData = function (data) {\n    var ret = null;\n    var preferredMFA = data.PreferredMfaSetting;\n    // if the user has used Auth.setPreferredMFA() to setup the mfa type\n    // then the \"PreferredMfaSetting\" would exist in the response\n    if (preferredMFA) {\n      ret = preferredMFA;\n    } else {\n      // if mfaList exists but empty, then its noMFA\n      var mfaList = data.UserMFASettingList;\n      if (!mfaList) {\n        // if SMS was enabled by using Auth.enableSMS(),\n        // the response would contain MFAOptions\n        // as for now Cognito only supports for SMS, so we will say it is 'SMS_MFA'\n        // if it does not exist, then it should be NOMFA\n        var MFAOptions = data.MFAOptions;\n        if (MFAOptions) {\n          ret = 'SMS_MFA';\n        } else {\n          ret = 'NOMFA';\n        }\n      } else if (mfaList.length === 0) {\n        ret = 'NOMFA';\n      } else {\n        logger.debug('invalid case for getPreferredMFA', data);\n      }\n    }\n    return ret;\n  };\n  AuthClass.prototype._getUserData = function (user, params) {\n    return new Promise(function (res, rej) {\n      user.getUserData(function (err, data) {\n        if (err) {\n          logger.debug('getting user data failed', err);\n          rej(err);\n          return;\n        } else {\n          res(data);\n          return;\n        }\n      }, params);\n    });\n  };\n  /**\n   * set preferred MFA method\n   * @param {CognitoUser} user - the current Cognito user\n   * @param {string} mfaMethod - preferred mfa method\n   * @return - A promise resolve if success\n   */\n  AuthClass.prototype.setPreferredMFA = function (user, mfaMethod) {\n    return __awaiter(this, void 0, void 0, function () {\n      var userData, smsMfaSettings, totpMfaSettings, _a, mfaList, currentMFAType, that;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4 /*yield*/, this._getUserData(user, {\n              bypassCache: true\n            })];\n          case 1:\n            userData = _b.sent();\n            smsMfaSettings = null;\n            totpMfaSettings = null;\n            _a = mfaMethod;\n            switch (_a) {\n              case 'TOTP' || 'SOFTWARE_TOKEN_MFA':\n                return [3 /*break*/, 2];\n              case 'SMS' || 'SMS_MFA':\n                return [3 /*break*/, 3];\n              case 'NOMFA':\n                return [3 /*break*/, 4];\n            }\n            return [3 /*break*/, 6];\n          case 2:\n            totpMfaSettings = {\n              PreferredMfa: true,\n              Enabled: true\n            };\n            return [3 /*break*/, 7];\n          case 3:\n            smsMfaSettings = {\n              PreferredMfa: true,\n              Enabled: true\n            };\n            return [3 /*break*/, 7];\n          case 4:\n            mfaList = userData['UserMFASettingList'];\n            return [4 /*yield*/, this._getMfaTypeFromUserData(userData)];\n          case 5:\n            currentMFAType = _b.sent();\n            if (currentMFAType === 'NOMFA') {\n              return [2 /*return*/, Promise.resolve('No change for mfa type')];\n            } else if (currentMFAType === 'SMS_MFA') {\n              smsMfaSettings = {\n                PreferredMfa: false,\n                Enabled: false\n              };\n            } else if (currentMFAType === 'SOFTWARE_TOKEN_MFA') {\n              totpMfaSettings = {\n                PreferredMfa: false,\n                Enabled: false\n              };\n            } else {\n              return [2 /*return*/, this.rejectAuthError(AuthErrorTypes.InvalidMFA)];\n            }\n            // if there is a UserMFASettingList in the response\n            // we need to disable every mfa type in that list\n            if (mfaList && mfaList.length !== 0) {\n              // to disable SMS or TOTP if exists in that list\n              mfaList.forEach(function (mfaType) {\n                if (mfaType === 'SMS_MFA') {\n                  smsMfaSettings = {\n                    PreferredMfa: false,\n                    Enabled: false\n                  };\n                } else if (mfaType === 'SOFTWARE_TOKEN_MFA') {\n                  totpMfaSettings = {\n                    PreferredMfa: false,\n                    Enabled: false\n                  };\n                }\n              });\n            }\n            return [3 /*break*/, 7];\n          case 6:\n            logger.debug('no validmfa method provided');\n            return [2 /*return*/, this.rejectAuthError(AuthErrorTypes.NoMFA)];\n          case 7:\n            that = this;\n            return [2 /*return*/, new Promise(function (res, rej) {\n              user.setUserMfaPreference(smsMfaSettings, totpMfaSettings, function (err, result) {\n                if (err) {\n                  logger.debug('Set user mfa preference error', err);\n                  return rej(err);\n                }\n                logger.debug('Set user mfa success', result);\n                logger.debug('Caching the latest user data into local');\n                // cache the latest result into user data\n                user.getUserData(function (err, data) {\n                  if (err) {\n                    logger.debug('getting user data failed', err);\n                    return rej(err);\n                  } else {\n                    return res(result);\n                  }\n                }, {\n                  bypassCache: true\n                });\n              });\n            })];\n        }\n      });\n    });\n  };\n  /**\n   * diable SMS\n   * @deprecated\n   * @param {CognitoUser} user - the current user\n   * @return - A promise resolves is success\n   */\n  AuthClass.prototype.disableSMS = function (user) {\n    return new Promise(function (res, rej) {\n      user.disableMFA(function (err, data) {\n        if (err) {\n          logger.debug('disable mfa failed', err);\n          rej(err);\n          return;\n        }\n        logger.debug('disable mfa succeed', data);\n        res(data);\n        return;\n      });\n    });\n  };\n  /**\n   * enable SMS\n   * @deprecated\n   * @param {CognitoUser} user - the current user\n   * @return - A promise resolves is success\n   */\n  AuthClass.prototype.enableSMS = function (user) {\n    return new Promise(function (res, rej) {\n      user.enableMFA(function (err, data) {\n        if (err) {\n          logger.debug('enable mfa failed', err);\n          rej(err);\n          return;\n        }\n        logger.debug('enable mfa succeed', data);\n        res(data);\n        return;\n      });\n    });\n  };\n  /**\n   * Setup TOTP\n   * @param {CognitoUser} user - the current user\n   * @return - A promise resolves with the secret code if success\n   */\n  AuthClass.prototype.setupTOTP = function (user) {\n    return new Promise(function (res, rej) {\n      user.associateSoftwareToken({\n        onFailure: function (err) {\n          logger.debug('associateSoftwareToken failed', err);\n          rej(err);\n          return;\n        },\n        associateSecretCode: function (secretCode) {\n          logger.debug('associateSoftwareToken sucess', secretCode);\n          res(secretCode);\n          return;\n        }\n      });\n    });\n  };\n  /**\n   * verify TOTP setup\n   * @param {CognitoUser} user - the current user\n   * @param {string} challengeAnswer - challenge answer\n   * @return - A promise resolves is success\n   */\n  AuthClass.prototype.verifyTotpToken = function (user, challengeAnswer) {\n    logger.debug('verfication totp token', user, challengeAnswer);\n    return new Promise(function (res, rej) {\n      user.verifySoftwareToken(challengeAnswer, 'My TOTP device', {\n        onFailure: function (err) {\n          logger.debug('verifyTotpToken failed', err);\n          rej(err);\n          return;\n        },\n        onSuccess: function (data) {\n          logger.debug('verifyTotpToken success', data);\n          res(data);\n          return;\n        }\n      });\n    });\n  };\n  /**\n   * Send MFA code to confirm sign in\n   * @param {Object} user - The CognitoUser object\n   * @param {String} code - The confirmation code\n   */\n  AuthClass.prototype.confirmSignIn = function (user, code, mfaType, clientMetadata) {\n    var _this = this;\n    if (clientMetadata === void 0) {\n      clientMetadata = this._config.clientMetadata;\n    }\n    if (!code) {\n      return this.rejectAuthError(AuthErrorTypes.EmptyCode);\n    }\n    var that = this;\n    return new Promise(function (resolve, reject) {\n      user.sendMFACode(code, {\n        onSuccess: function (session) {\n          return __awaiter(_this, void 0, void 0, function () {\n            var cred, e_3;\n            return __generator(this, function (_a) {\n              switch (_a.label) {\n                case 0:\n                  logger.debug(session);\n                  _a.label = 1;\n                case 1:\n                  _a.trys.push([1, 4, 5, 6]);\n                  return [4 /*yield*/, Credentials.clear()];\n                case 2:\n                  _a.sent();\n                  return [4 /*yield*/, Credentials.set(session, 'session')];\n                case 3:\n                  cred = _a.sent();\n                  logger.debug('succeed to get cognito credentials', cred);\n                  return [3 /*break*/, 6];\n                case 4:\n                  e_3 = _a.sent();\n                  logger.debug('cannot get cognito credentials', e_3);\n                  return [3 /*break*/, 6];\n                case 5:\n                  that.user = user;\n                  dispatchAuthEvent('signIn', user, user + \" has signed in\");\n                  resolve(user);\n                  return [7 /*endfinally*/];\n                case 6:\n                  return [2 /*return*/];\n              }\n            });\n          });\n        },\n\n        onFailure: function (err) {\n          logger.debug('confirm signIn failure', err);\n          reject(err);\n        }\n      }, mfaType, clientMetadata);\n    });\n  };\n  AuthClass.prototype.completeNewPassword = function (user, password, requiredAttributes, clientMetadata) {\n    var _this = this;\n    if (clientMetadata === void 0) {\n      clientMetadata = this._config.clientMetadata;\n    }\n    if (!password) {\n      return this.rejectAuthError(AuthErrorTypes.EmptyPassword);\n    }\n    var that = this;\n    return new Promise(function (resolve, reject) {\n      user.completeNewPasswordChallenge(password, requiredAttributes, {\n        onSuccess: function (session) {\n          return __awaiter(_this, void 0, void 0, function () {\n            var cred, e_4;\n            return __generator(this, function (_a) {\n              switch (_a.label) {\n                case 0:\n                  logger.debug(session);\n                  _a.label = 1;\n                case 1:\n                  _a.trys.push([1, 4, 5, 6]);\n                  return [4 /*yield*/, Credentials.clear()];\n                case 2:\n                  _a.sent();\n                  return [4 /*yield*/, Credentials.set(session, 'session')];\n                case 3:\n                  cred = _a.sent();\n                  logger.debug('succeed to get cognito credentials', cred);\n                  return [3 /*break*/, 6];\n                case 4:\n                  e_4 = _a.sent();\n                  logger.debug('cannot get cognito credentials', e_4);\n                  return [3 /*break*/, 6];\n                case 5:\n                  that.user = user;\n                  dispatchAuthEvent('signIn', user, user + \" has signed in\");\n                  resolve(user);\n                  return [7 /*endfinally*/];\n                case 6:\n                  return [2 /*return*/];\n              }\n            });\n          });\n        },\n\n        onFailure: function (err) {\n          logger.debug('completeNewPassword failure', err);\n          dispatchAuthEvent('completeNewPassword_failure', err, _this.user + \" failed to complete the new password flow\");\n          reject(err);\n        },\n        mfaRequired: function (challengeName, challengeParam) {\n          logger.debug('signIn MFA required');\n          user['challengeName'] = challengeName;\n          user['challengeParam'] = challengeParam;\n          resolve(user);\n        },\n        mfaSetup: function (challengeName, challengeParam) {\n          logger.debug('signIn mfa setup', challengeName);\n          user['challengeName'] = challengeName;\n          user['challengeParam'] = challengeParam;\n          resolve(user);\n        }\n      }, clientMetadata);\n    });\n  };\n  /**\n   * Send the answer to a custom challenge\n   * @param {CognitoUser} user - The CognitoUser object\n   * @param {String} challengeResponses - The confirmation code\n   */\n  AuthClass.prototype.sendCustomChallengeAnswer = function (user, challengeResponses, clientMetadata) {\n    var _this = this;\n    if (clientMetadata === void 0) {\n      clientMetadata = this._config.clientMetadata;\n    }\n    if (!this.userPool) {\n      return this.rejectNoUserPool();\n    }\n    if (!challengeResponses) {\n      return this.rejectAuthError(AuthErrorTypes.EmptyChallengeResponse);\n    }\n    var that = this;\n    return new Promise(function (resolve, reject) {\n      user.sendCustomChallengeAnswer(challengeResponses, _this.authCallbacks(user, resolve, reject), clientMetadata);\n    });\n  };\n  /**\n   * Update an authenticated users' attributes\n   * @param {CognitoUser} - The currently logged in user object\n   * @return {Promise}\n   **/\n  AuthClass.prototype.updateUserAttributes = function (user, attributes, clientMetadata) {\n    if (clientMetadata === void 0) {\n      clientMetadata = this._config.clientMetadata;\n    }\n    var attributeList = [];\n    var that = this;\n    return new Promise(function (resolve, reject) {\n      that.userSession(user).then(function (session) {\n        for (var key in attributes) {\n          if (key !== 'sub' && key.indexOf('_verified') < 0) {\n            var attr = {\n              Name: key,\n              Value: attributes[key]\n            };\n            attributeList.push(attr);\n          }\n        }\n        user.updateAttributes(attributeList, function (err, result) {\n          if (err) {\n            return reject(err);\n          } else {\n            return resolve(result);\n          }\n        }, clientMetadata);\n      });\n    });\n  };\n  /**\n   * Return user attributes\n   * @param {Object} user - The CognitoUser object\n   * @return - A promise resolves to user attributes if success\n   */\n  AuthClass.prototype.userAttributes = function (user) {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      _this.userSession(user).then(function (session) {\n        user.getUserAttributes(function (err, attributes) {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(attributes);\n          }\n        });\n      });\n    });\n  };\n  AuthClass.prototype.verifiedContact = function (user) {\n    var that = this;\n    return this.userAttributes(user).then(function (attributes) {\n      var attrs = that.attributesToObject(attributes);\n      var unverified = {};\n      var verified = {};\n      if (attrs['email']) {\n        if (attrs['email_verified']) {\n          verified['email'] = attrs['email'];\n        } else {\n          unverified['email'] = attrs['email'];\n        }\n      }\n      if (attrs['phone_number']) {\n        if (attrs['phone_number_verified']) {\n          verified['phone_number'] = attrs['phone_number'];\n        } else {\n          unverified['phone_number'] = attrs['phone_number'];\n        }\n      }\n      return {\n        verified: verified,\n        unverified: unverified\n      };\n    });\n  };\n  /**\n   * Get current authenticated user\n   * @return - A promise resolves to current authenticated CognitoUser if success\n   */\n  AuthClass.prototype.currentUserPoolUser = function (params) {\n    var _this = this;\n    if (!this.userPool) {\n      return this.rejectNoUserPool();\n    }\n    var that = this;\n    return new Promise(function (res, rej) {\n      _this._storageSync.then(function () {\n        var user = that.userPool.getCurrentUser();\n        if (!user) {\n          logger.debug('Failed to get user from user pool');\n          rej('No current user');\n          return;\n        }\n        // refresh the session if the session expired.\n        user.getSession(function (err, session) {\n          if (err) {\n            logger.debug('Failed to get the user session', err);\n            rej(err);\n            return;\n          }\n          // get user data from Cognito\n          var bypassCache = params ? params.bypassCache : false;\n          // validate the token's scope fisrt before calling this function\n          var _a = session.getAccessToken().decodePayload().scope,\n            scope = _a === void 0 ? '' : _a;\n          if (scope.split(' ').includes(USER_ADMIN_SCOPE)) {\n            user.getUserData(function (err, data) {\n              if (err) {\n                logger.debug('getting user data failed', err);\n                // Make sure the user is still valid\n                if (err.message === 'User is disabled' || err.message === 'User does not exist.') {\n                  rej(err);\n                } else {\n                  // the error may also be thrown when lack of permissions to get user info etc\n                  // in that case we just bypass the error\n                  res(user);\n                }\n                return;\n              }\n              var preferredMFA = data.PreferredMfaSetting || 'NOMFA';\n              var attributeList = [];\n              for (var i = 0; i < data.UserAttributes.length; i++) {\n                var attribute = {\n                  Name: data.UserAttributes[i].Name,\n                  Value: data.UserAttributes[i].Value\n                };\n                var userAttribute = new CognitoUserAttribute(attribute);\n                attributeList.push(userAttribute);\n              }\n              var attributes = that.attributesToObject(attributeList);\n              Object.assign(user, {\n                attributes: attributes,\n                preferredMFA: preferredMFA\n              });\n              return res(user);\n            }, {\n              bypassCache: bypassCache\n            });\n          } else {\n            logger.debug(\"Unable to get the user data because the \" + USER_ADMIN_SCOPE + \" \" + \"is not in the scopes of the access token\");\n            return res(user);\n          }\n        });\n      }).catch(function (e) {\n        logger.debug('Failed to sync cache info into memory', e);\n        return rej(e);\n      });\n    });\n  };\n  /**\n   * Get current authenticated user\n   * @param {CurrentUserOpts} - options for getting the current user\n   * @return - A promise resolves to current authenticated CognitoUser if success\n   */\n  AuthClass.prototype.currentAuthenticatedUser = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var federatedUser, e_5, user, e_6;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            logger.debug('getting current authenticated user');\n            federatedUser = null;\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n            return [4 /*yield*/, this._storageSync];\n          case 2:\n            _a.sent();\n            return [3 /*break*/, 4];\n          case 3:\n            e_5 = _a.sent();\n            logger.debug('Failed to sync cache info into memory', e_5);\n            throw e_5;\n          case 4:\n            try {\n              federatedUser = JSON.parse(this._storage.getItem('aws-amplify-federatedInfo')).user;\n            } catch (e) {\n              logger.debug('cannot load federated user from auth storage');\n            }\n            if (!federatedUser) return [3 /*break*/, 5];\n            this.user = federatedUser;\n            logger.debug('get current authenticated federated user', this.user);\n            return [2 /*return*/, this.user];\n          case 5:\n            logger.debug('get current authenticated userpool user');\n            user = null;\n            _a.label = 6;\n          case 6:\n            _a.trys.push([6, 8,, 9]);\n            return [4 /*yield*/, this.currentUserPoolUser(params)];\n          case 7:\n            user = _a.sent();\n            return [3 /*break*/, 9];\n          case 8:\n            e_6 = _a.sent();\n            if (e_6 === 'No userPool') {\n              logger.error('Cannot get the current user because the user pool is missing. ' + 'Please make sure the Auth module is configured with a valid Cognito User Pool ID');\n            }\n            logger.debug('The user is not authenticated by the error', e_6);\n            throw 'not authenticated';\n          case 9:\n            this.user = user;\n            return [2 /*return*/, this.user];\n        }\n      });\n    });\n  };\n  /**\n   * Get current user's session\n   * @return - A promise resolves to session object if success\n   */\n  AuthClass.prototype.currentSession = function () {\n    var that = this;\n    logger.debug('Getting current session');\n    // Purposely not calling the reject method here because we don't need a console error\n    if (!this.userPool) {\n      return Promise.reject();\n    }\n    return new Promise(function (res, rej) {\n      that.currentUserPoolUser().then(function (user) {\n        that.userSession(user).then(function (session) {\n          res(session);\n          return;\n        }).catch(function (e) {\n          logger.debug('Failed to get the current session', e);\n          rej(e);\n          return;\n        });\n      }).catch(function (e) {\n        logger.debug('Failed to get the current user', e);\n        rej(e);\n        return;\n      });\n    });\n  };\n  /**\n   * Get the corresponding user session\n   * @param {Object} user - The CognitoUser object\n   * @return - A promise resolves to the session\n   */\n  AuthClass.prototype.userSession = function (user) {\n    if (!user) {\n      logger.debug('the user is null');\n      return this.rejectAuthError(AuthErrorTypes.NoUserSession);\n    }\n    return new Promise(function (resolve, reject) {\n      logger.debug('Getting the session from this user:', user);\n      user.getSession(function (err, session) {\n        if (err) {\n          logger.debug('Failed to get the session from user', user);\n          reject(err);\n          return;\n        } else {\n          logger.debug('Succeed to get the user session', session);\n          resolve(session);\n          return;\n        }\n      });\n    });\n  };\n  /**\n   * Get  authenticated credentials of current user.\n   * @return - A promise resolves to be current user's credentials\n   */\n  AuthClass.prototype.currentUserCredentials = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var that, e_7, federatedInfo;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            that = this;\n            logger.debug('Getting current user credentials');\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n            return [4 /*yield*/, this._storageSync];\n          case 2:\n            _a.sent();\n            return [3 /*break*/, 4];\n          case 3:\n            e_7 = _a.sent();\n            logger.debug('Failed to sync cache info into memory', e_7);\n            throw e_7;\n          case 4:\n            federatedInfo = null;\n            try {\n              federatedInfo = JSON.parse(this._storage.getItem('aws-amplify-federatedInfo'));\n            } catch (e) {\n              logger.debug('failed to get or parse item aws-amplify-federatedInfo', e);\n            }\n            if (federatedInfo) {\n              // refresh the jwt token here if necessary\n              return [2 /*return*/, Credentials.refreshFederatedToken(federatedInfo)];\n            } else {\n              return [2 /*return*/, this.currentSession().then(function (session) {\n                logger.debug('getting session success', session);\n                return Credentials.set(session, 'session');\n              }).catch(function (error) {\n                logger.debug('getting session failed', error);\n                return Credentials.set(null, 'guest');\n              })];\n            }\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  AuthClass.prototype.currentCredentials = function () {\n    logger.debug('getting current credntials');\n    return Credentials.get();\n  };\n  /**\n   * Initiate an attribute confirmation request\n   * @param {Object} user - The CognitoUser\n   * @param {Object} attr - The attributes to be verified\n   * @return - A promise resolves to callback data if success\n   */\n  AuthClass.prototype.verifyUserAttribute = function (user, attr, clientMetadata) {\n    if (clientMetadata === void 0) {\n      clientMetadata = this._config.clientMetadata;\n    }\n    return new Promise(function (resolve, reject) {\n      user.getAttributeVerificationCode(attr, {\n        onSuccess: function () {\n          return resolve();\n        },\n        onFailure: function (err) {\n          return reject(err);\n        },\n        clientMetadata: clientMetadata\n      });\n    });\n  };\n  /**\n   * Confirm an attribute using a confirmation code\n   * @param {Object} user - The CognitoUser\n   * @param {Object} attr - The attribute to be verified\n   * @param {String} code - The confirmation code\n   * @return - A promise resolves to callback data if success\n   */\n  AuthClass.prototype.verifyUserAttributeSubmit = function (user, attr, code) {\n    if (!code) {\n      return this.rejectAuthError(AuthErrorTypes.EmptyCode);\n    }\n    return new Promise(function (resolve, reject) {\n      user.verifyAttribute(attr, code, {\n        onSuccess: function (data) {\n          resolve(data);\n          return;\n        },\n        onFailure: function (err) {\n          reject(err);\n          return;\n        }\n      });\n    });\n  };\n  AuthClass.prototype.verifyCurrentUserAttribute = function (attr) {\n    var that = this;\n    return that.currentUserPoolUser().then(function (user) {\n      return that.verifyUserAttribute(user, attr);\n    });\n  };\n  /**\n   * Confirm current user's attribute using a confirmation code\n   * @param {Object} attr - The attribute to be verified\n   * @param {String} code - The confirmation code\n   * @return - A promise resolves to callback data if success\n   */\n  AuthClass.prototype.verifyCurrentUserAttributeSubmit = function (attr, code) {\n    var that = this;\n    return that.currentUserPoolUser().then(function (user) {\n      return that.verifyUserAttributeSubmit(user, attr, code);\n    });\n  };\n  AuthClass.prototype.cognitoIdentitySignOut = function (opts, user) {\n    return __awaiter(this, void 0, void 0, function () {\n      var e_8, isSignedInHostedUI;\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n            return [4 /*yield*/, this._storageSync];\n          case 1:\n            _a.sent();\n            return [3 /*break*/, 3];\n          case 2:\n            e_8 = _a.sent();\n            logger.debug('Failed to sync cache info into memory', e_8);\n            throw e_8;\n          case 3:\n            isSignedInHostedUI = this._oAuthHandler && this._storage.getItem('amplify-signin-with-hostedUI') === 'true';\n            return [2 /*return*/, new Promise(function (res, rej) {\n              if (opts && opts.global) {\n                logger.debug('user global sign out', user);\n                // in order to use global signout\n                // we must validate the user as an authenticated user by using getSession\n                user.getSession(function (err, result) {\n                  if (err) {\n                    logger.debug('failed to get the user session', err);\n                    return rej(err);\n                  }\n                  user.globalSignOut({\n                    onSuccess: function (data) {\n                      logger.debug('global sign out success');\n                      if (isSignedInHostedUI) {\n                        return res(_this._oAuthHandler.signOut());\n                      } else {\n                        return res();\n                      }\n                    },\n                    onFailure: function (err) {\n                      logger.debug('global sign out failed', err);\n                      return rej(err);\n                    }\n                  });\n                });\n              } else {\n                logger.debug('user sign out', user);\n                user.signOut();\n                if (isSignedInHostedUI) {\n                  return res(_this._oAuthHandler.signOut());\n                } else {\n                  return res();\n                }\n              }\n            })];\n        }\n      });\n    });\n  };\n  /**\n   * Sign out method\n   * @\n   * @return - A promise resolved if success\n   */\n  AuthClass.prototype.signOut = function (opts) {\n    return __awaiter(this, void 0, void 0, function () {\n      var e_9, user;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n            return [4 /*yield*/, this.cleanCachedItems()];\n          case 1:\n            _a.sent();\n            return [3 /*break*/, 3];\n          case 2:\n            e_9 = _a.sent();\n            logger.debug('failed to clear cached items');\n            return [3 /*break*/, 3];\n          case 3:\n            if (!this.userPool) return [3 /*break*/, 7];\n            user = this.userPool.getCurrentUser();\n            if (!user) return [3 /*break*/, 5];\n            return [4 /*yield*/, this.cognitoIdentitySignOut(opts, user)];\n          case 4:\n            _a.sent();\n            return [3 /*break*/, 6];\n          case 5:\n            logger.debug('no current Cognito user');\n            _a.label = 6;\n          case 6:\n            return [3 /*break*/, 8];\n          case 7:\n            logger.debug('no Congito User pool');\n            _a.label = 8;\n          case 8:\n            /**\n             * Note for future refactor - no reliable way to get username with\n             * Cognito User Pools vs Identity when federating with Social Providers\n             * This is why we need a well structured session object that can be inspected\n             * and information passed back in the message below for Hub dispatch\n             */\n            dispatchAuthEvent('signOut', this.user, \"A user has been signed out\");\n            this.user = null;\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  AuthClass.prototype.cleanCachedItems = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            // clear cognito cached item\n            return [4 /*yield*/, Credentials.clear()];\n          case 1:\n            // clear cognito cached item\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * Change a password for an authenticated user\n   * @param {Object} user - The CognitoUser object\n   * @param {String} oldPassword - the current password\n   * @param {String} newPassword - the requested new password\n   * @return - A promise resolves if success\n   */\n  AuthClass.prototype.changePassword = function (user, oldPassword, newPassword, clientMetadata) {\n    var _this = this;\n    if (clientMetadata === void 0) {\n      clientMetadata = this._config.clientMetadata;\n    }\n    return new Promise(function (resolve, reject) {\n      _this.userSession(user).then(function (session) {\n        user.changePassword(oldPassword, newPassword, function (err, data) {\n          if (err) {\n            logger.debug('change password failure', err);\n            return reject(err);\n          } else {\n            return resolve(data);\n          }\n        }, clientMetadata);\n      });\n    });\n  };\n  /**\n   * Initiate a forgot password request\n   * @param {String} username - the username to change password\n   * @return - A promise resolves if success\n   */\n  AuthClass.prototype.forgotPassword = function (username, clientMetadata) {\n    if (clientMetadata === void 0) {\n      clientMetadata = this._config.clientMetadata;\n    }\n    if (!this.userPool) {\n      return this.rejectNoUserPool();\n    }\n    if (!username) {\n      return this.rejectAuthError(AuthErrorTypes.EmptyUsername);\n    }\n    var user = this.createCognitoUser(username);\n    return new Promise(function (resolve, reject) {\n      user.forgotPassword({\n        onSuccess: function () {\n          resolve();\n          return;\n        },\n        onFailure: function (err) {\n          logger.debug('forgot password failure', err);\n          dispatchAuthEvent('forgotPassword_failure', err, username + \" forgotPassword failed\");\n          reject(err);\n          return;\n        },\n        inputVerificationCode: function (data) {\n          dispatchAuthEvent('forgotPassword', user, username + \" has initiated forgot password flow\");\n          resolve(data);\n          return;\n        }\n      }, clientMetadata);\n    });\n  };\n  /**\n   * Confirm a new password using a confirmation Code\n   * @param {String} username - The username\n   * @param {String} code - The confirmation code\n   * @param {String} password - The new password\n   * @return - A promise that resolves if success\n   */\n  AuthClass.prototype.forgotPasswordSubmit = function (username, code, password, clientMetadata) {\n    if (clientMetadata === void 0) {\n      clientMetadata = this._config.clientMetadata;\n    }\n    if (!this.userPool) {\n      return this.rejectNoUserPool();\n    }\n    if (!username) {\n      return this.rejectAuthError(AuthErrorTypes.EmptyUsername);\n    }\n    if (!code) {\n      return this.rejectAuthError(AuthErrorTypes.EmptyCode);\n    }\n    if (!password) {\n      return this.rejectAuthError(AuthErrorTypes.EmptyPassword);\n    }\n    var user = this.createCognitoUser(username);\n    return new Promise(function (resolve, reject) {\n      user.confirmPassword(code, password, {\n        onSuccess: function () {\n          dispatchAuthEvent('forgotPasswordSubmit', user, username + \" forgotPasswordSubmit successful\");\n          resolve();\n          return;\n        },\n        onFailure: function (err) {\n          dispatchAuthEvent('forgotPasswordSubmit_failure', err, username + \" forgotPasswordSubmit failed\");\n          reject(err);\n          return;\n        }\n      }, clientMetadata);\n    });\n  };\n  /**\n   * Get user information\n   * @async\n   * @return {Object }- current User's information\n   */\n  AuthClass.prototype.currentUserInfo = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var source, user, attributes, userAttrs, credentials, e_10, info, err_1, user;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            source = Credentials.getCredSource();\n            if (!(!source || source === 'aws' || source === 'userPool')) return [3 /*break*/, 9];\n            return [4 /*yield*/, this.currentUserPoolUser().catch(function (err) {\n              return logger.debug(err);\n            })];\n          case 1:\n            user = _a.sent();\n            if (!user) {\n              return [2 /*return*/, null];\n            }\n            _a.label = 2;\n          case 2:\n            _a.trys.push([2, 8,, 9]);\n            return [4 /*yield*/, this.userAttributes(user)];\n          case 3:\n            attributes = _a.sent();\n            userAttrs = this.attributesToObject(attributes);\n            credentials = null;\n            _a.label = 4;\n          case 4:\n            _a.trys.push([4, 6,, 7]);\n            return [4 /*yield*/, this.currentCredentials()];\n          case 5:\n            credentials = _a.sent();\n            return [3 /*break*/, 7];\n          case 6:\n            e_10 = _a.sent();\n            logger.debug('Failed to retrieve credentials while getting current user info', e_10);\n            return [3 /*break*/, 7];\n          case 7:\n            info = {\n              id: credentials ? credentials.identityId : undefined,\n              username: user.getUsername(),\n              attributes: userAttrs\n            };\n            return [2 /*return*/, info];\n          case 8:\n            err_1 = _a.sent();\n            logger.debug('currentUserInfo error', err_1);\n            return [2 /*return*/, {}];\n          case 9:\n            if (source === 'federated') {\n              user = this.user;\n              return [2 /*return*/, user ? user : {}];\n            }\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  AuthClass.prototype.federatedSignIn = function (providerOrOptions, response, user) {\n    return __awaiter(this, void 0, void 0, function () {\n      var options, provider, customState, client_id, redirect_uri, provider, loggedInUser, token, identity_id, expires_at, credentials, currentUser;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this._config.identityPoolId && !this._config.userPoolId) {\n              throw new Error(\"Federation requires either a User Pool or Identity Pool in config\");\n            }\n            // Ensure backwards compatability\n            if (typeof providerOrOptions === 'undefined') {\n              if (this._config.identityPoolId && !this._config.userPoolId) {\n                throw new Error(\"Federation with Identity Pools requires tokens passed as arguments\");\n              }\n            }\n            if (!(isFederatedSignInOptions(providerOrOptions) || isFederatedSignInOptionsCustom(providerOrOptions) || typeof providerOrOptions === 'undefined')) return [3 /*break*/, 1];\n            options = providerOrOptions || {\n              provider: CognitoHostedUIIdentityProvider.Cognito\n            };\n            provider = isFederatedSignInOptions(options) ? options.provider : options.customProvider;\n            customState = isFederatedSignInOptions(options) ? options.customState : options.customState;\n            if (this._config.userPoolId) {\n              client_id = isCognitoHostedOpts(this._config.oauth) ? this._config.userPoolWebClientId : this._config.oauth.clientID;\n              redirect_uri = isCognitoHostedOpts(this._config.oauth) ? this._config.oauth.redirectSignIn : this._config.oauth.redirectUri;\n              this._oAuthHandler.oauthSignIn(this._config.oauth.responseType, this._config.oauth.domain, redirect_uri, client_id, provider, customState);\n            }\n            return [3 /*break*/, 4];\n          case 1:\n            provider = providerOrOptions;\n            // To check if the user is already logged in\n            try {\n              loggedInUser = JSON.stringify(JSON.parse(this._storage.getItem('aws-amplify-federatedInfo')).user);\n              if (loggedInUser) {\n                logger.warn(\"There is already a signed in user: \" + loggedInUser + \" in your app.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tYou should not call Auth.federatedSignIn method again as it may cause unexpected behavior.\");\n              }\n            } catch (e) {}\n            token = response.token, identity_id = response.identity_id, expires_at = response.expires_at;\n            return [4 /*yield*/, Credentials.set({\n              provider: provider,\n              token: token,\n              identity_id: identity_id,\n              user: user,\n              expires_at: expires_at\n            }, 'federation')];\n          case 2:\n            credentials = _a.sent();\n            return [4 /*yield*/, this.currentAuthenticatedUser()];\n          case 3:\n            currentUser = _a.sent();\n            dispatchAuthEvent('signIn', currentUser, \"A user \" + currentUser.username + \" has been signed in\");\n            logger.debug('federated sign in credentials', credentials);\n            return [2 /*return*/, credentials];\n          case 4:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * Used to complete the OAuth flow with or without the Cognito Hosted UI\n   * @param {String} URL - optional parameter for customers to pass in the response URL\n   */\n  AuthClass.prototype._handleAuthResponse = function (URL) {\n    return __awaiter(this, void 0, void 0, function () {\n      var currentUrl, hasCodeOrError, hasTokenOrError, _a, accessToken, idToken, refreshToken, state, session, credentials, isCustomStateIncluded, currentUser, _b, customState, err_2;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            if (!this._config.userPoolId) {\n              throw new Error(\"OAuth responses require a User Pool defined in config\");\n            }\n            dispatchAuthEvent('parsingCallbackUrl', {\n              url: URL\n            }, \"The callback url is being parsed\");\n            currentUrl = URL || (JS.browserOrNode().isBrowser ? window.location.href : '');\n            hasCodeOrError = !!(parse(currentUrl).query || '').split('&').map(function (entry) {\n              return entry.split('=');\n            }).find(function (_a) {\n              var k = _a[0];\n              return k === 'code' || k === 'error';\n            });\n            hasTokenOrError = !!(parse(currentUrl).hash || '#').substr(1).split('&').map(function (entry) {\n              return entry.split('=');\n            }).find(function (_a) {\n              var k = _a[0];\n              return k === 'access_token' || k === 'error';\n            });\n            if (!(hasCodeOrError || hasTokenOrError)) return [3 /*break*/, 6];\n            _c.label = 1;\n          case 1:\n            _c.trys.push([1, 5,, 6]);\n            return [4 /*yield*/, this._oAuthHandler.handleAuthResponse(currentUrl)];\n          case 2:\n            _a = _c.sent(), accessToken = _a.accessToken, idToken = _a.idToken, refreshToken = _a.refreshToken, state = _a.state;\n            session = new CognitoUserSession({\n              IdToken: new CognitoIdToken({\n                IdToken: idToken\n              }),\n              RefreshToken: new CognitoRefreshToken({\n                RefreshToken: refreshToken\n              }),\n              AccessToken: new CognitoAccessToken({\n                AccessToken: accessToken\n              })\n            });\n            credentials = void 0;\n            if (!this._config.identityPoolId) return [3 /*break*/, 4];\n            return [4 /*yield*/, Credentials.set(session, 'session')];\n          case 3:\n            credentials = _c.sent();\n            logger.debug('AWS credentials', credentials);\n            _c.label = 4;\n          case 4:\n            isCustomStateIncluded = /-/.test(state);\n            currentUser = this.createCognitoUser(session.getIdToken().decodePayload()['cognito:username']);\n            dispatchAuthEvent('signIn', currentUser, \"A user \" + currentUser.getUsername() + \" has been signed in\");\n            dispatchAuthEvent('cognitoHostedUI', currentUser, \"A user \" + currentUser.getUsername() + \" has been signed in via Cognito Hosted UI\");\n            if (isCustomStateIncluded) {\n              _b = state.split('-'), customState = _b[1];\n              dispatchAuthEvent('customOAuthState', customState, \"State for user \" + currentUser.getUsername());\n            }\n            // This calls cacheTokens() in Cognito SDK\n            currentUser.setSignInUserSession(session);\n            //#endregion\n            if (window && typeof window.history !== 'undefined') {\n              window.history.replaceState({}, null, this._config.oauth.redirectSignIn);\n            }\n            return [2 /*return*/, credentials];\n          case 5:\n            err_2 = _c.sent();\n            logger.debug('Error in cognito hosted auth response', err_2);\n            dispatchAuthEvent('signIn_failure', err_2, \"The OAuth response flow failed\");\n            dispatchAuthEvent('cognitoHostedUI_failure', err_2, \"A failure occurred when returning to the Cognito Hosted UI\");\n            dispatchAuthEvent('customState_failure', err_2, \"A failure occurred when returning state\");\n            throw err_2;\n          case 6:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * Compact version of credentials\n   * @param {Object} credentials\n   * @return {Object} - Credentials\n   */\n  AuthClass.prototype.essentialCredentials = function (credentials) {\n    return {\n      accessKeyId: credentials.accessKeyId,\n      sessionToken: credentials.sessionToken,\n      secretAccessKey: credentials.secretAccessKey,\n      identityId: credentials.identityId,\n      authenticated: credentials.authenticated\n    };\n  };\n  AuthClass.prototype.attributesToObject = function (attributes) {\n    var obj = {};\n    if (attributes) {\n      attributes.map(function (attribute) {\n        if (attribute.Value === 'true') {\n          obj[attribute.Name] = true;\n        } else if (attribute.Value === 'false') {\n          obj[attribute.Name] = false;\n        } else {\n          obj[attribute.Name] = attribute.Value;\n        }\n      });\n    }\n    return obj;\n  };\n  AuthClass.prototype.createCognitoUser = function (username) {\n    var userData = {\n      Username: username,\n      Pool: this.userPool\n    };\n    userData.Storage = this._storage;\n    var authenticationFlowType = this._config.authenticationFlowType;\n    var user = new CognitoUser(userData);\n    if (authenticationFlowType) {\n      user.setAuthenticationFlowType(authenticationFlowType);\n    }\n    return user;\n  };\n  AuthClass.prototype._isValidAuthStorage = function (obj) {\n    // We need to check if the obj has the functions of Storage\n    return !!obj && typeof obj.getItem === 'function' && typeof obj.setItem === 'function' && typeof obj.removeItem === 'function' && typeof obj.clear === 'function';\n  };\n  AuthClass.prototype.noUserPoolErrorHandler = function (config) {\n    if (config) {\n      if (!config.userPoolId || !config.identityPoolId) {\n        return AuthErrorTypes.MissingAuthConfig;\n      }\n    }\n    return AuthErrorTypes.NoConfig;\n  };\n  AuthClass.prototype.rejectAuthError = function (type) {\n    return Promise.reject(new AuthError(type));\n  };\n  AuthClass.prototype.rejectNoUserPool = function () {\n    var type = this.noUserPoolErrorHandler(this._config);\n    return Promise.reject(new NoUserPoolError(type));\n  };\n  return AuthClass;\n}();\nexport default AuthClass;","map":{"version":3,"names":["isUsernamePasswordOpts","isCognitoHostedOpts","isFederatedSignInOptions","isFederatedSignInOptionsCustom","AWS","ConsoleLogger","Logger","Constants","Hub","JS","Parser","Credentials","StorageHelper","CookieStorage","CognitoUserPool","AuthenticationDetails","CognitoUser","CognitoUserSession","CognitoUserAttribute","CognitoIdToken","CognitoRefreshToken","CognitoAccessToken","parse","OAuth","default","urlListener","AuthError","NoUserPoolError","AuthErrorTypes","logger","USER_ADMIN_SCOPE","AMPLIFY_SYMBOL","Symbol","for","dispatchAuthEvent","event","data","message","dispatch","CognitoHostedUIIdentityProvider","AuthClass","config","_this","userPool","user","configure","currentUserCredentials","bind","update","customUserAgent","userAgent","warn","listen","_a","payload","_storage","setItem","removeItem","prototype","getModuleName","_config","debug","conf","Object","assign","parseMobilehubConfig","Auth","userPoolId","userPoolWebClientId","cookieStorage","oauth","region","identityPoolId","mandatorySignIn","refreshHandlers","identityPoolRegion","clientMetadata","storage","getStorage","_isValidAuthStorage","error","Error","_storageSync","Promise","resolve","userPoolData","UserPoolId","ClientId","Storage","cognitoHostedUIConfig","awsCognito","undefined","cognitoAuthParams","cognitoClientId","domain","scopes","redirectSignIn","redirectSignOut","responseType","urlOpener","_oAuthHandler","url","_handleAuthResponse","signUp","params","restOfAttrs","_i","arguments","length","rejectNoUserPool","username","password","attributes","validationData","email","phone_number","push","Name","Value","attrs_1","keys","map","key","ele","rejectAuthError","SignUpError","EmptyUsername","EmptyPassword","reject","err","confirmSignUp","code","options","EmptyCode","createCognitoUser","forceAliasCreation","confirmRegistration","resendSignUp","resendConfirmationCode","signIn","usernameOrSignInOpts","pw","InvalidUsername","authDetails","Username","Password","ValidationData","ClientMetadata","signInWithPassword","signInWithoutPassword","authCallbacks","that","onSuccess","session","__awaiter","clear","sent","set","cred","e_1","currentUserPoolUser","currentUser","getUsername","e_2","onFailure","customChallenge","challengeParam","mfaRequired","challengeName","mfaSetup","newPasswordRequired","userAttributes","requiredAttributes","totpRequired","selectMFAType","authenticateUser","setAuthenticationFlowType","initiateAuth","getMFAOptions","res","rej","mfaOptions","getPreferredMFA","bypassCache","getUserData","mfaType","_getMfaTypeFromUserData","ret","preferredMFA","PreferredMfaSetting","mfaList","UserMFASettingList","MFAOptions","_getUserData","setPreferredMFA","mfaMethod","userData","_b","smsMfaSettings","totpMfaSettings","PreferredMfa","Enabled","currentMFAType","InvalidMFA","forEach","NoMFA","setUserMfaPreference","result","disableSMS","disableMFA","enableSMS","enableMFA","setupTOTP","associateSoftwareToken","associateSecretCode","secretCode","verifyTotpToken","challengeAnswer","verifySoftwareToken","confirmSignIn","sendMFACode","e_3","completeNewPassword","completeNewPasswordChallenge","e_4","sendCustomChallengeAnswer","challengeResponses","EmptyChallengeResponse","updateUserAttributes","attributeList","userSession","then","indexOf","attr","updateAttributes","getUserAttributes","verifiedContact","attrs","attributesToObject","unverified","verified","getCurrentUser","getSession","getAccessToken","decodePayload","scope","split","includes","i","UserAttributes","attribute","userAttribute","catch","e","currentAuthenticatedUser","federatedUser","e_5","JSON","getItem","e_6","currentSession","NoUserSession","e_7","federatedInfo","refreshFederatedToken","currentCredentials","get","verifyUserAttribute","getAttributeVerificationCode","verifyUserAttributeSubmit","verifyAttribute","verifyCurrentUserAttribute","verifyCurrentUserAttributeSubmit","cognitoIdentitySignOut","opts","e_8","isSignedInHostedUI","global","globalSignOut","signOut","cleanCachedItems","changePassword","oldPassword","newPassword","forgotPassword","inputVerificationCode","forgotPasswordSubmit","confirmPassword","currentUserInfo","source","getCredSource","userAttrs","credentials","e_10","info","id","identityId","err_1","federatedSignIn","providerOrOptions","response","provider","Cognito","customProvider","customState","client_id","clientID","redirect_uri","redirectUri","oauthSignIn","loggedInUser","stringify","token","identity_id","expires_at","URL","currentUrl","browserOrNode","isBrowser","window","location","href","hasCodeOrError","query","entry","find","k","hasTokenOrError","hash","substr","handleAuthResponse","_c","accessToken","idToken","refreshToken","state","IdToken","RefreshToken","AccessToken","isCustomStateIncluded","test","getIdToken","setSignInUserSession","history","replaceState","err_2","essentialCredentials","accessKeyId","sessionToken","secretAccessKey","authenticated","obj","Pool","authenticationFlowType","noUserPoolErrorHandler","MissingAuthConfig","NoConfig","type"],"sources":["C:\\Study\\6805\\React\\reacthtml\\node_modules\\@aws-amplify\\auth\\src\\Auth.ts"],"sourcesContent":["/*\n * Copyright 2017-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n *     http://aws.amazon.com/apache2.0/\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\n\nimport {\n\tAuthOptions,\n\tFederatedResponse,\n\tSignUpParams,\n\tFederatedUser,\n\tConfirmSignUpOptions,\n\tSignOutOpts,\n\tCurrentUserOpts,\n\tGetPreferredMFAOpts,\n\tSignInOpts,\n\tisUsernamePasswordOpts,\n\tisCognitoHostedOpts,\n\tisFederatedSignInOptions,\n\tisFederatedSignInOptionsCustom,\n\tFederatedSignInOptionsCustom,\n\tLegacyProvider,\n\tFederatedSignInOptions,\n\tAwsCognitoOAuthOpts,\n\tClientMetaData,\n} from './types';\n\nimport {\n\tAWS,\n\tConsoleLogger as Logger,\n\tConstants,\n\tHub,\n\tJS,\n\tParser,\n\tCredentials,\n\tStorageHelper,\n\tICredentials,\n\tPlatform,\n} from '@aws-amplify/core';\nimport {\n\tCookieStorage,\n\tCognitoUserPool,\n\tAuthenticationDetails,\n\tICognitoUserPoolData,\n\tICognitoUserData,\n\tISignUpResult,\n\tCognitoUser,\n\tMFAOption,\n\tCognitoUserSession,\n\tIAuthenticationCallback,\n\tICognitoUserAttributeData,\n\tCognitoUserAttribute,\n\tCognitoIdToken,\n\tCognitoRefreshToken,\n\tCognitoAccessToken,\n} from 'amazon-cognito-identity-js';\n\nimport { parse } from 'url';\nimport OAuth from './OAuth/OAuth';\nimport { default as urlListener } from './urlListener';\nimport { AuthError, NoUserPoolError } from './Errors';\nimport { AuthErrorTypes } from './types/Auth';\n\nconst logger = new Logger('AuthClass');\nconst USER_ADMIN_SCOPE = 'aws.cognito.signin.user.admin';\n\nconst AMPLIFY_SYMBOL = (typeof Symbol !== 'undefined' &&\ntypeof Symbol.for === 'function'\n\t? Symbol.for('amplify_default')\n\t: '@@amplify_default') as Symbol;\n\nconst dispatchAuthEvent = (event: string, data: any, message: string) => {\n\tHub.dispatch('auth', { event, data, message }, 'Auth', AMPLIFY_SYMBOL);\n};\n\nexport enum CognitoHostedUIIdentityProvider {\n\tCognito = 'COGNITO',\n\tGoogle = 'Google',\n\tFacebook = 'Facebook',\n\tAmazon = 'LoginWithAmazon',\n}\n\n/**\n * Provide authentication steps\n */\nexport default class AuthClass {\n\tprivate _config: AuthOptions;\n\tprivate userPool = null;\n\tprivate user: any = null;\n\tprivate _oAuthHandler: OAuth;\n\tprivate _storage;\n\tprivate _storageSync;\n\n\t/**\n\t * Initialize Auth with AWS configurations\n\t * @param {Object} config - Configuration of the Auth\n\t */\n\tconstructor(config: AuthOptions) {\n\t\tthis.configure(config);\n\t\tthis.currentUserCredentials = this.currentUserCredentials.bind(this);\n\n\t\tif (AWS.config) {\n\t\t\tAWS.config.update({ customUserAgent: Constants.userAgent });\n\t\t} else {\n\t\t\tlogger.warn('No AWS.config');\n\t\t}\n\n\t\tHub.listen('auth', ({ payload }) => {\n\t\t\tconst { event } = payload;\n\t\t\tswitch (event) {\n\t\t\t\tcase 'signIn':\n\t\t\t\t\tthis._storage.setItem('amplify-signin-with-hostedUI', 'false');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'signOut':\n\t\t\t\t\tthis._storage.removeItem('amplify-signin-with-hostedUI');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'cognitoHostedUI':\n\t\t\t\t\tthis._storage.setItem('amplify-signin-with-hostedUI', 'true');\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic getModuleName() {\n\t\treturn 'Auth';\n\t}\n\n\tconfigure(config) {\n\t\tif (!config) return this._config || {};\n\t\tlogger.debug('configure Auth');\n\t\tconst conf = Object.assign(\n\t\t\t{},\n\t\t\tthis._config,\n\t\t\tParser.parseMobilehubConfig(config).Auth,\n\t\t\tconfig\n\t\t);\n\t\tthis._config = conf;\n\t\tconst {\n\t\t\tuserPoolId,\n\t\t\tuserPoolWebClientId,\n\t\t\tcookieStorage,\n\t\t\toauth,\n\t\t\tregion,\n\t\t\tidentityPoolId,\n\t\t\tmandatorySignIn,\n\t\t\trefreshHandlers,\n\t\t\tidentityPoolRegion,\n\t\t\tclientMetadata,\n\t\t} = this._config;\n\n\t\tif (!this._config.storage) {\n\t\t\t// backward compatbility\n\t\t\tif (cookieStorage) this._storage = new CookieStorage(cookieStorage);\n\t\t\telse {\n\t\t\t\tthis._storage = new StorageHelper().getStorage();\n\t\t\t}\n\t\t} else {\n\t\t\tif (!this._isValidAuthStorage(this._config.storage)) {\n\t\t\t\tlogger.error('The storage in the Auth config is not valid!');\n\t\t\t\tthrow new Error('Empty storage object');\n\t\t\t}\n\t\t\tthis._storage = this._config.storage;\n\t\t}\n\n\t\tthis._storageSync = Promise.resolve();\n\t\tif (typeof this._storage['sync'] === 'function') {\n\t\t\tthis._storageSync = this._storage['sync']();\n\t\t}\n\n\t\tif (userPoolId) {\n\t\t\tconst userPoolData: ICognitoUserPoolData = {\n\t\t\t\tUserPoolId: userPoolId,\n\t\t\t\tClientId: userPoolWebClientId,\n\t\t\t};\n\t\t\tuserPoolData.Storage = this._storage;\n\n\t\t\tthis.userPool = new CognitoUserPool(userPoolData);\n\t\t}\n\n\t\tCredentials.configure({\n\t\t\tmandatorySignIn,\n\t\t\tregion: identityPoolRegion || region,\n\t\t\tuserPoolId,\n\t\t\tidentityPoolId,\n\t\t\trefreshHandlers,\n\t\t\tstorage: this._storage,\n\t\t});\n\n\t\t// initiailize cognitoauth client if hosted ui options provided\n\t\t// to keep backward compatibility:\n\t\tconst cognitoHostedUIConfig = oauth\n\t\t\t? isCognitoHostedOpts(this._config.oauth)\n\t\t\t\t? oauth\n\t\t\t\t: (<any>oauth).awsCognito\n\t\t\t: undefined;\n\n\t\tif (cognitoHostedUIConfig) {\n\t\t\tconst cognitoAuthParams = Object.assign(\n\t\t\t\t{\n\t\t\t\t\tcognitoClientId: userPoolWebClientId,\n\t\t\t\t\tUserPoolId: userPoolId,\n\t\t\t\t\tdomain: cognitoHostedUIConfig['domain'],\n\t\t\t\t\tscopes: cognitoHostedUIConfig['scope'],\n\t\t\t\t\tredirectSignIn: cognitoHostedUIConfig['redirectSignIn'],\n\t\t\t\t\tredirectSignOut: cognitoHostedUIConfig['redirectSignOut'],\n\t\t\t\t\tresponseType: cognitoHostedUIConfig['responseType'],\n\t\t\t\t\tStorage: this._storage,\n\t\t\t\t\turlOpener: cognitoHostedUIConfig['urlOpener'],\n\t\t\t\t\tclientMetadata,\n\t\t\t\t},\n\t\t\t\tcognitoHostedUIConfig['options']\n\t\t\t);\n\n\t\t\tthis._oAuthHandler = new OAuth({\n\t\t\t\tscopes: cognitoAuthParams.scopes,\n\t\t\t\tconfig: cognitoAuthParams,\n\t\t\t\tcognitoClientId: cognitoAuthParams.cognitoClientId,\n\t\t\t});\n\n\t\t\t// **NOTE** - Remove this in a future major release as it is a breaking change\n\t\t\turlListener(({ url }) => {\n\t\t\t\tthis._handleAuthResponse(url);\n\t\t\t});\n\t\t}\n\n\t\tdispatchAuthEvent(\n\t\t\t'configured',\n\t\t\tnull,\n\t\t\t`The Auth category has been configured successfully`\n\t\t);\n\t\treturn this._config;\n\t}\n\n\t/**\n\t * Sign up with username, password and other attrbutes like phone, email\n\t * @param {String | object} params - The user attirbutes used for signin\n\t * @param {String[]} restOfAttrs - for the backward compatability\n\t * @return - A promise resolves callback data if success\n\t */\n\tpublic signUp(\n\t\tparams: string | SignUpParams,\n\t\t...restOfAttrs: string[]\n\t): Promise<ISignUpResult> {\n\t\tif (!this.userPool) {\n\t\t\treturn this.rejectNoUserPool();\n\t\t}\n\n\t\tlet username: string = null;\n\t\tlet password: string = null;\n\t\tconst attributes: object[] = [];\n\t\tlet validationData: object[] = null;\n\t\tlet clientMetadata;\n\n\t\tif (params && typeof params === 'string') {\n\t\t\tusername = params;\n\t\t\tpassword = restOfAttrs ? restOfAttrs[0] : null;\n\t\t\tconst email: string = restOfAttrs ? restOfAttrs[1] : null;\n\t\t\tconst phone_number: string = restOfAttrs ? restOfAttrs[2] : null;\n\t\t\tif (email) attributes.push({ Name: 'email', Value: email });\n\t\t\tif (phone_number)\n\t\t\t\tattributes.push({ Name: 'phone_number', Value: phone_number });\n\t\t} else if (params && typeof params === 'object') {\n\t\t\tusername = params['username'];\n\t\t\tpassword = params['password'];\n\n\t\t\tif (params && params.clientMetadata) {\n\t\t\t\tclientMetadata = params.clientMetadata;\n\t\t\t} else if (this._config.clientMetadata) {\n\t\t\t\tclientMetadata = this._config.clientMetadata;\n\t\t\t}\n\n\t\t\tconst attrs = params['attributes'];\n\t\t\tif (attrs) {\n\t\t\t\tObject.keys(attrs).map(key => {\n\t\t\t\t\tconst ele: object = { Name: key, Value: attrs[key] };\n\t\t\t\t\tattributes.push(ele);\n\t\t\t\t});\n\t\t\t}\n\t\t\tvalidationData = params['validationData'] || null;\n\t\t} else {\n\t\t\treturn this.rejectAuthError(AuthErrorTypes.SignUpError);\n\t\t}\n\n\t\tif (!username) {\n\t\t\treturn this.rejectAuthError(AuthErrorTypes.EmptyUsername);\n\t\t}\n\t\tif (!password) {\n\t\t\treturn this.rejectAuthError(AuthErrorTypes.EmptyPassword);\n\t\t}\n\n\t\tlogger.debug('signUp attrs:', attributes);\n\t\tlogger.debug('signUp validation data:', validationData);\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.userPool.signUp(\n\t\t\t\tusername,\n\t\t\t\tpassword,\n\t\t\t\tattributes,\n\t\t\t\tvalidationData,\n\t\t\t\t(err, data) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t\t\t'signUp_failure',\n\t\t\t\t\t\t\terr,\n\t\t\t\t\t\t\t`${username} failed to signup`\n\t\t\t\t\t\t);\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t\t\t'signUp',\n\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\t`${username} has signed up successfully`\n\t\t\t\t\t\t);\n\t\t\t\t\t\tresolve(data);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tclientMetadata\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * Send the verfication code to confirm sign up\n\t * @param {String} username - The username to be confirmed\n\t * @param {String} code - The verification code\n\t * @param {ConfirmSignUpOptions} options - other options for confirm signup\n\t * @return - A promise resolves callback data if success\n\t */\n\tpublic confirmSignUp(\n\t\tusername: string,\n\t\tcode: string,\n\t\toptions?: ConfirmSignUpOptions\n\t): Promise<any> {\n\t\tif (!this.userPool) {\n\t\t\treturn this.rejectNoUserPool();\n\t\t}\n\t\tif (!username) {\n\t\t\treturn this.rejectAuthError(AuthErrorTypes.EmptyUsername);\n\t\t}\n\t\tif (!code) {\n\t\t\treturn this.rejectAuthError(AuthErrorTypes.EmptyCode);\n\t\t}\n\n\t\tconst user = this.createCognitoUser(username);\n\t\tconst forceAliasCreation =\n\t\t\toptions && typeof options.forceAliasCreation === 'boolean'\n\t\t\t\t? options.forceAliasCreation\n\t\t\t\t: true;\n\n\t\tlet clientMetadata;\n\t\tif (options && options.clientMetadata) {\n\t\t\tclientMetadata = options.clientMetadata;\n\t\t} else if (this._config.clientMetadata) {\n\t\t\tclientMetadata = this._config.clientMetadata;\n\t\t}\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tuser.confirmRegistration(\n\t\t\t\tcode,\n\t\t\t\tforceAliasCreation,\n\t\t\t\t(err, data) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve(data);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tclientMetadata\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * Resend the verification code\n\t * @param {String} username - The username to be confirmed\n\t * @param {ClientMetadata} clientMetadata - Metadata to be passed to Cognito Lambda triggers\n\t * @return - A promise resolves data if success\n\t */\n\tpublic resendSignUp(\n\t\tusername: string,\n\t\tclientMetadata: ClientMetaData = this._config.clientMetadata\n\t): Promise<string> {\n\t\tif (!this.userPool) {\n\t\t\treturn this.rejectNoUserPool();\n\t\t}\n\t\tif (!username) {\n\t\t\treturn this.rejectAuthError(AuthErrorTypes.EmptyUsername);\n\t\t}\n\n\t\tconst user = this.createCognitoUser(username);\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tuser.resendConfirmationCode((err, data) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(data);\n\t\t\t\t}\n\t\t\t}, clientMetadata);\n\t\t});\n\t}\n\n\t/**\n\t * Sign in\n\t * @param {String | SignInOpts} usernameOrSignInOpts - The username to be signed in or the sign in options\n\t * @param {String} password - The password of the username\n\t * @return - A promise resolves the CognitoUser\n\t */\n\tpublic signIn(\n\t\tusernameOrSignInOpts: string | SignInOpts,\n\t\tpw?: string,\n\t\tclientMetadata: ClientMetaData = this._config.clientMetadata\n\t): Promise<CognitoUser | any> {\n\t\tif (!this.userPool) {\n\t\t\treturn this.rejectNoUserPool();\n\t\t}\n\t\tlet username = null;\n\t\tlet password = null;\n\t\tlet validationData = {};\n\n\t\t// for backward compatibility\n\t\tif (typeof usernameOrSignInOpts === 'string') {\n\t\t\tusername = usernameOrSignInOpts;\n\t\t\tpassword = pw;\n\t\t} else if (isUsernamePasswordOpts(usernameOrSignInOpts)) {\n\t\t\tif (typeof pw !== 'undefined') {\n\t\t\t\tlogger.warn(\n\t\t\t\t\t'The password should be defined under the first parameter object!'\n\t\t\t\t);\n\t\t\t}\n\t\t\tusername = usernameOrSignInOpts.username;\n\t\t\tpassword = usernameOrSignInOpts.password;\n\t\t\tvalidationData = usernameOrSignInOpts.validationData;\n\t\t} else {\n\t\t\treturn this.rejectAuthError(AuthErrorTypes.InvalidUsername);\n\t\t}\n\t\tif (!username) {\n\t\t\treturn this.rejectAuthError(AuthErrorTypes.EmptyUsername);\n\t\t}\n\t\tconst authDetails = new AuthenticationDetails({\n\t\t\tUsername: username,\n\t\t\tPassword: password,\n\t\t\tValidationData: validationData,\n\t\t\tClientMetadata: clientMetadata,\n\t\t});\n\t\tif (password) {\n\t\t\treturn this.signInWithPassword(authDetails);\n\t\t} else {\n\t\t\treturn this.signInWithoutPassword(authDetails);\n\t\t}\n\t}\n\n\t/**\n\t * Return an object with the authentication callbacks\n\t * @param {CognitoUser} user - the cognito user object\n\t * @param {} resolve - function called when resolving the current step\n\t * @param {} reject - function called when rejecting the current step\n\t * @return - an object with the callback methods for user authentication\n\t */\n\tprivate authCallbacks(\n\t\tuser: CognitoUser,\n\t\tresolve: (value?: CognitoUser | any) => void,\n\t\treject: (value?: any) => void\n\t): IAuthenticationCallback {\n\t\tconst that = this;\n\t\treturn {\n\t\t\tonSuccess: async session => {\n\t\t\t\tlogger.debug(session);\n\t\t\t\tdelete user['challengeName'];\n\t\t\t\tdelete user['challengeParam'];\n\t\t\t\ttry {\n\t\t\t\t\tawait Credentials.clear();\n\t\t\t\t\tconst cred = await Credentials.set(session, 'session');\n\t\t\t\t\tlogger.debug('succeed to get cognito credentials', cred);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tlogger.debug('cannot get cognito credentials', e);\n\t\t\t\t} finally {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// In order to get user attributes and MFA methods\n\t\t\t\t\t\t// We need to trigger currentUserPoolUser again\n\t\t\t\t\t\tconst currentUser = await this.currentUserPoolUser();\n\t\t\t\t\t\tthat.user = currentUser;\n\t\t\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t\t\t'signIn',\n\t\t\t\t\t\t\tcurrentUser,\n\t\t\t\t\t\t\t`A user ${user.getUsername()} has been signed in`\n\t\t\t\t\t\t);\n\t\t\t\t\t\tresolve(currentUser);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tlogger.error('Failed to get the signed in user', e);\n\t\t\t\t\t\treject(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tonFailure: err => {\n\t\t\t\tlogger.debug('signIn failure', err);\n\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t'signIn_failure',\n\t\t\t\t\terr,\n\t\t\t\t\t`${user.getUsername()} failed to signin`\n\t\t\t\t);\n\t\t\t\treject(err);\n\t\t\t},\n\t\t\tcustomChallenge: challengeParam => {\n\t\t\t\tlogger.debug('signIn custom challenge answer required');\n\t\t\t\tuser['challengeName'] = 'CUSTOM_CHALLENGE';\n\t\t\t\tuser['challengeParam'] = challengeParam;\n\t\t\t\tresolve(user);\n\t\t\t},\n\t\t\tmfaRequired: (challengeName, challengeParam) => {\n\t\t\t\tlogger.debug('signIn MFA required');\n\t\t\t\tuser['challengeName'] = challengeName;\n\t\t\t\tuser['challengeParam'] = challengeParam;\n\t\t\t\tresolve(user);\n\t\t\t},\n\t\t\tmfaSetup: (challengeName, challengeParam) => {\n\t\t\t\tlogger.debug('signIn mfa setup', challengeName);\n\t\t\t\tuser['challengeName'] = challengeName;\n\t\t\t\tuser['challengeParam'] = challengeParam;\n\t\t\t\tresolve(user);\n\t\t\t},\n\t\t\tnewPasswordRequired: (userAttributes, requiredAttributes) => {\n\t\t\t\tlogger.debug('signIn new password');\n\t\t\t\tuser['challengeName'] = 'NEW_PASSWORD_REQUIRED';\n\t\t\t\tuser['challengeParam'] = {\n\t\t\t\t\tuserAttributes,\n\t\t\t\t\trequiredAttributes,\n\t\t\t\t};\n\t\t\t\tresolve(user);\n\t\t\t},\n\t\t\ttotpRequired: (challengeName, challengeParam) => {\n\t\t\t\tlogger.debug('signIn totpRequired');\n\t\t\t\tuser['challengeName'] = challengeName;\n\t\t\t\tuser['challengeParam'] = challengeParam;\n\t\t\t\tresolve(user);\n\t\t\t},\n\t\t\tselectMFAType: (challengeName, challengeParam) => {\n\t\t\t\tlogger.debug('signIn selectMFAType', challengeName);\n\t\t\t\tuser['challengeName'] = challengeName;\n\t\t\t\tuser['challengeParam'] = challengeParam;\n\t\t\t\tresolve(user);\n\t\t\t},\n\t\t};\n\t}\n\n\t/**\n\t * Sign in with a password\n\t * @private\n\t * @param {AuthenticationDetails} authDetails - the user sign in data\n\t * @return - A promise resolves the CognitoUser object if success or mfa required\n\t */\n\tprivate signInWithPassword(\n\t\tauthDetails: AuthenticationDetails\n\t): Promise<CognitoUser | any> {\n\t\tconst user = this.createCognitoUser(authDetails.getUsername());\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tuser.authenticateUser(\n\t\t\t\tauthDetails,\n\t\t\t\tthis.authCallbacks(user, resolve, reject)\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * Sign in without a password\n\t * @private\n\t * @param {AuthenticationDetails} authDetails - the user sign in data\n\t * @return - A promise resolves the CognitoUser object if success or mfa required\n\t */\n\tprivate signInWithoutPassword(\n\t\tauthDetails: AuthenticationDetails\n\t): Promise<CognitoUser | any> {\n\t\tconst user = this.createCognitoUser(authDetails.getUsername());\n\t\tuser.setAuthenticationFlowType('CUSTOM_AUTH');\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tuser.initiateAuth(authDetails, this.authCallbacks(user, resolve, reject));\n\t\t});\n\t}\n\n\t/**\n\t * get user current preferred mfa option\n\t * this method doesn't work with totp, we need to deprecate it.\n\t * @deprecated\n\t * @param {CognitoUser} user - the current user\n\t * @return - A promise resolves the current preferred mfa option if success\n\t */\n\tpublic getMFAOptions(user: CognitoUser | any): Promise<MFAOption[]> {\n\t\treturn new Promise((res, rej) => {\n\t\t\tuser.getMFAOptions((err, mfaOptions) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tlogger.debug('get MFA Options failed', err);\n\t\t\t\t\trej(err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tlogger.debug('get MFA options success', mfaOptions);\n\t\t\t\tres(mfaOptions);\n\t\t\t\treturn;\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * get preferred mfa method\n\t * @param {CognitoUser} user - the current cognito user\n\t * @param {GetPreferredMFAOpts} params - options for getting the current user preferred MFA\n\t */\n\tpublic getPreferredMFA(\n\t\tuser: CognitoUser | any,\n\t\tparams?: GetPreferredMFAOpts\n\t): Promise<string> {\n\t\tconst that = this;\n\t\treturn new Promise((res, rej) => {\n\t\t\tconst bypassCache = params ? params.bypassCache : false;\n\t\t\tuser.getUserData(\n\t\t\t\t(err, data) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tlogger.debug('getting preferred mfa failed', err);\n\t\t\t\t\t\trej(err);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst mfaType = that._getMfaTypeFromUserData(data);\n\t\t\t\t\tif (!mfaType) {\n\t\t\t\t\t\trej('invalid MFA Type');\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tres(mfaType);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{ bypassCache }\n\t\t\t);\n\t\t});\n\t}\n\n\tprivate _getMfaTypeFromUserData(data) {\n\t\tlet ret = null;\n\t\tconst preferredMFA = data.PreferredMfaSetting;\n\t\t// if the user has used Auth.setPreferredMFA() to setup the mfa type\n\t\t// then the \"PreferredMfaSetting\" would exist in the response\n\t\tif (preferredMFA) {\n\t\t\tret = preferredMFA;\n\t\t} else {\n\t\t\t// if mfaList exists but empty, then its noMFA\n\t\t\tconst mfaList = data.UserMFASettingList;\n\t\t\tif (!mfaList) {\n\t\t\t\t// if SMS was enabled by using Auth.enableSMS(),\n\t\t\t\t// the response would contain MFAOptions\n\t\t\t\t// as for now Cognito only supports for SMS, so we will say it is 'SMS_MFA'\n\t\t\t\t// if it does not exist, then it should be NOMFA\n\t\t\t\tconst MFAOptions = data.MFAOptions;\n\t\t\t\tif (MFAOptions) {\n\t\t\t\t\tret = 'SMS_MFA';\n\t\t\t\t} else {\n\t\t\t\t\tret = 'NOMFA';\n\t\t\t\t}\n\t\t\t} else if (mfaList.length === 0) {\n\t\t\t\tret = 'NOMFA';\n\t\t\t} else {\n\t\t\t\tlogger.debug('invalid case for getPreferredMFA', data);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tprivate _getUserData(user, params) {\n\t\treturn new Promise((res, rej) => {\n\t\t\tuser.getUserData((err, data) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tlogger.debug('getting user data failed', err);\n\t\t\t\t\trej(err);\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tres(data);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}, params);\n\t\t});\n\t}\n\n\t/**\n\t * set preferred MFA method\n\t * @param {CognitoUser} user - the current Cognito user\n\t * @param {string} mfaMethod - preferred mfa method\n\t * @return - A promise resolve if success\n\t */\n\tpublic async setPreferredMFA(\n\t\tuser: CognitoUser | any,\n\t\tmfaMethod: 'TOTP' | 'SMS' | 'NOMFA'\n\t): Promise<string> {\n\t\tconst userData = await this._getUserData(user, { bypassCache: true });\n\t\tlet smsMfaSettings = null;\n\t\tlet totpMfaSettings = null;\n\n\t\tswitch (mfaMethod) {\n\t\t\tcase 'TOTP' || 'SOFTWARE_TOKEN_MFA':\n\t\t\t\ttotpMfaSettings = {\n\t\t\t\t\tPreferredMfa: true,\n\t\t\t\t\tEnabled: true,\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\tcase 'SMS' || 'SMS_MFA':\n\t\t\t\tsmsMfaSettings = {\n\t\t\t\t\tPreferredMfa: true,\n\t\t\t\t\tEnabled: true,\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\tcase 'NOMFA':\n\t\t\t\tconst mfaList = userData['UserMFASettingList'];\n\t\t\t\tconst currentMFAType = await this._getMfaTypeFromUserData(userData);\n\t\t\t\tif (currentMFAType === 'NOMFA') {\n\t\t\t\t\treturn Promise.resolve('No change for mfa type');\n\t\t\t\t} else if (currentMFAType === 'SMS_MFA') {\n\t\t\t\t\tsmsMfaSettings = {\n\t\t\t\t\t\tPreferredMfa: false,\n\t\t\t\t\t\tEnabled: false,\n\t\t\t\t\t};\n\t\t\t\t} else if (currentMFAType === 'SOFTWARE_TOKEN_MFA') {\n\t\t\t\t\ttotpMfaSettings = {\n\t\t\t\t\t\tPreferredMfa: false,\n\t\t\t\t\t\tEnabled: false,\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\treturn this.rejectAuthError(AuthErrorTypes.InvalidMFA);\n\t\t\t\t}\n\t\t\t\t// if there is a UserMFASettingList in the response\n\t\t\t\t// we need to disable every mfa type in that list\n\t\t\t\tif (mfaList && mfaList.length !== 0) {\n\t\t\t\t\t// to disable SMS or TOTP if exists in that list\n\t\t\t\t\tmfaList.forEach(mfaType => {\n\t\t\t\t\t\tif (mfaType === 'SMS_MFA') {\n\t\t\t\t\t\t\tsmsMfaSettings = {\n\t\t\t\t\t\t\t\tPreferredMfa: false,\n\t\t\t\t\t\t\t\tEnabled: false,\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else if (mfaType === 'SOFTWARE_TOKEN_MFA') {\n\t\t\t\t\t\t\ttotpMfaSettings = {\n\t\t\t\t\t\t\t\tPreferredMfa: false,\n\t\t\t\t\t\t\t\tEnabled: false,\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlogger.debug('no validmfa method provided');\n\t\t\t\treturn this.rejectAuthError(AuthErrorTypes.NoMFA);\n\t\t}\n\n\t\tconst that = this;\n\t\treturn new Promise<string>((res, rej) => {\n\t\t\tuser.setUserMfaPreference(\n\t\t\t\tsmsMfaSettings,\n\t\t\t\ttotpMfaSettings,\n\t\t\t\t(err, result) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tlogger.debug('Set user mfa preference error', err);\n\t\t\t\t\t\treturn rej(err);\n\t\t\t\t\t}\n\t\t\t\t\tlogger.debug('Set user mfa success', result);\n\t\t\t\t\tlogger.debug('Caching the latest user data into local');\n\t\t\t\t\t// cache the latest result into user data\n\t\t\t\t\tuser.getUserData(\n\t\t\t\t\t\t(err, data) => {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\tlogger.debug('getting user data failed', err);\n\t\t\t\t\t\t\t\treturn rej(err);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn res(result);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{ bypassCache: true }\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * diable SMS\n\t * @deprecated\n\t * @param {CognitoUser} user - the current user\n\t * @return - A promise resolves is success\n\t */\n\tpublic disableSMS(user: CognitoUser): Promise<string> {\n\t\treturn new Promise((res, rej) => {\n\t\t\tuser.disableMFA((err, data) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tlogger.debug('disable mfa failed', err);\n\t\t\t\t\trej(err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tlogger.debug('disable mfa succeed', data);\n\t\t\t\tres(data);\n\t\t\t\treturn;\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * enable SMS\n\t * @deprecated\n\t * @param {CognitoUser} user - the current user\n\t * @return - A promise resolves is success\n\t */\n\tpublic enableSMS(user: CognitoUser): Promise<string> {\n\t\treturn new Promise((res, rej) => {\n\t\t\tuser.enableMFA((err, data) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tlogger.debug('enable mfa failed', err);\n\t\t\t\t\trej(err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tlogger.debug('enable mfa succeed', data);\n\t\t\t\tres(data);\n\t\t\t\treturn;\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Setup TOTP\n\t * @param {CognitoUser} user - the current user\n\t * @return - A promise resolves with the secret code if success\n\t */\n\tpublic setupTOTP(user: CognitoUser | any): Promise<string> {\n\t\treturn new Promise((res, rej) => {\n\t\t\tuser.associateSoftwareToken({\n\t\t\t\tonFailure: err => {\n\t\t\t\t\tlogger.debug('associateSoftwareToken failed', err);\n\t\t\t\t\trej(err);\n\t\t\t\t\treturn;\n\t\t\t\t},\n\t\t\t\tassociateSecretCode: secretCode => {\n\t\t\t\t\tlogger.debug('associateSoftwareToken sucess', secretCode);\n\t\t\t\t\tres(secretCode);\n\t\t\t\t\treturn;\n\t\t\t\t},\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * verify TOTP setup\n\t * @param {CognitoUser} user - the current user\n\t * @param {string} challengeAnswer - challenge answer\n\t * @return - A promise resolves is success\n\t */\n\tpublic verifyTotpToken(\n\t\tuser: CognitoUser | any,\n\t\tchallengeAnswer: string\n\t): Promise<CognitoUserSession> {\n\t\tlogger.debug('verfication totp token', user, challengeAnswer);\n\t\treturn new Promise((res, rej) => {\n\t\t\tuser.verifySoftwareToken(challengeAnswer, 'My TOTP device', {\n\t\t\t\tonFailure: err => {\n\t\t\t\t\tlogger.debug('verifyTotpToken failed', err);\n\t\t\t\t\trej(err);\n\t\t\t\t\treturn;\n\t\t\t\t},\n\t\t\t\tonSuccess: data => {\n\t\t\t\t\tlogger.debug('verifyTotpToken success', data);\n\t\t\t\t\tres(data);\n\t\t\t\t\treturn;\n\t\t\t\t},\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Send MFA code to confirm sign in\n\t * @param {Object} user - The CognitoUser object\n\t * @param {String} code - The confirmation code\n\t */\n\tpublic confirmSignIn(\n\t\tuser: CognitoUser | any,\n\t\tcode: string,\n\t\tmfaType?: 'SMS_MFA' | 'SOFTWARE_TOKEN_MFA' | null,\n\t\tclientMetadata: ClientMetaData = this._config.clientMetadata\n\t): Promise<CognitoUser | any> {\n\t\tif (!code) {\n\t\t\treturn this.rejectAuthError(AuthErrorTypes.EmptyCode);\n\t\t}\n\n\t\tconst that = this;\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tuser.sendMFACode(\n\t\t\t\tcode,\n\t\t\t\t{\n\t\t\t\t\tonSuccess: async session => {\n\t\t\t\t\t\tlogger.debug(session);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait Credentials.clear();\n\t\t\t\t\t\t\tconst cred = await Credentials.set(session, 'session');\n\t\t\t\t\t\t\tlogger.debug('succeed to get cognito credentials', cred);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tlogger.debug('cannot get cognito credentials', e);\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tthat.user = user;\n\n\t\t\t\t\t\t\tdispatchAuthEvent('signIn', user, `${user} has signed in`);\n\t\t\t\t\t\t\tresolve(user);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tonFailure: err => {\n\t\t\t\t\t\tlogger.debug('confirm signIn failure', err);\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tmfaType,\n\t\t\t\tclientMetadata\n\t\t\t);\n\t\t});\n\t}\n\n\tpublic completeNewPassword(\n\t\tuser: CognitoUser | any,\n\t\tpassword: string,\n\t\trequiredAttributes: any,\n\t\tclientMetadata: ClientMetaData = this._config.clientMetadata\n\t): Promise<CognitoUser | any> {\n\t\tif (!password) {\n\t\t\treturn this.rejectAuthError(AuthErrorTypes.EmptyPassword);\n\t\t}\n\n\t\tconst that = this;\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tuser.completeNewPasswordChallenge(\n\t\t\t\tpassword,\n\t\t\t\trequiredAttributes,\n\t\t\t\t{\n\t\t\t\t\tonSuccess: async session => {\n\t\t\t\t\t\tlogger.debug(session);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait Credentials.clear();\n\t\t\t\t\t\t\tconst cred = await Credentials.set(session, 'session');\n\t\t\t\t\t\t\tlogger.debug('succeed to get cognito credentials', cred);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tlogger.debug('cannot get cognito credentials', e);\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tthat.user = user;\n\t\t\t\t\t\t\tdispatchAuthEvent('signIn', user, `${user} has signed in`);\n\t\t\t\t\t\t\tresolve(user);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tonFailure: err => {\n\t\t\t\t\t\tlogger.debug('completeNewPassword failure', err);\n\t\t\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t\t\t'completeNewPassword_failure',\n\t\t\t\t\t\t\terr,\n\t\t\t\t\t\t\t`${this.user} failed to complete the new password flow`\n\t\t\t\t\t\t);\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t},\n\t\t\t\t\tmfaRequired: (challengeName, challengeParam) => {\n\t\t\t\t\t\tlogger.debug('signIn MFA required');\n\t\t\t\t\t\tuser['challengeName'] = challengeName;\n\t\t\t\t\t\tuser['challengeParam'] = challengeParam;\n\t\t\t\t\t\tresolve(user);\n\t\t\t\t\t},\n\t\t\t\t\tmfaSetup: (challengeName, challengeParam) => {\n\t\t\t\t\t\tlogger.debug('signIn mfa setup', challengeName);\n\t\t\t\t\t\tuser['challengeName'] = challengeName;\n\t\t\t\t\t\tuser['challengeParam'] = challengeParam;\n\t\t\t\t\t\tresolve(user);\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tclientMetadata\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * Send the answer to a custom challenge\n\t * @param {CognitoUser} user - The CognitoUser object\n\t * @param {String} challengeResponses - The confirmation code\n\t */\n\tpublic sendCustomChallengeAnswer(\n\t\tuser: CognitoUser | any,\n\t\tchallengeResponses: string,\n\t\tclientMetadata: ClientMetaData = this._config.clientMetadata\n\t): Promise<CognitoUser | any> {\n\t\tif (!this.userPool) {\n\t\t\treturn this.rejectNoUserPool();\n\t\t}\n\t\tif (!challengeResponses) {\n\t\t\treturn this.rejectAuthError(AuthErrorTypes.EmptyChallengeResponse);\n\t\t}\n\n\t\tconst that = this;\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tuser.sendCustomChallengeAnswer(\n\t\t\t\tchallengeResponses,\n\t\t\t\tthis.authCallbacks(user, resolve, reject),\n\t\t\t\tclientMetadata\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * Update an authenticated users' attributes\n\t * @param {CognitoUser} - The currently logged in user object\n\t * @return {Promise}\n\t **/\n\tpublic updateUserAttributes(\n\t\tuser: CognitoUser | any,\n\t\tattributes: object,\n\t\tclientMetadata: ClientMetaData = this._config.clientMetadata\n\t): Promise<string> {\n\t\tconst attributeList: ICognitoUserAttributeData[] = [];\n\t\tconst that = this;\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthat.userSession(user).then(session => {\n\t\t\t\tfor (const key in attributes) {\n\t\t\t\t\tif (key !== 'sub' && key.indexOf('_verified') < 0) {\n\t\t\t\t\t\tconst attr: ICognitoUserAttributeData = {\n\t\t\t\t\t\t\tName: key,\n\t\t\t\t\t\t\tValue: attributes[key],\n\t\t\t\t\t\t};\n\t\t\t\t\t\tattributeList.push(attr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tuser.updateAttributes(\n\t\t\t\t\tattributeList,\n\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn resolve(result);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tclientMetadata\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\t}\n\t/**\n\t * Return user attributes\n\t * @param {Object} user - The CognitoUser object\n\t * @return - A promise resolves to user attributes if success\n\t */\n\tpublic userAttributes(\n\t\tuser: CognitoUser | any\n\t): Promise<CognitoUserAttribute[]> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.userSession(user).then(session => {\n\t\t\t\tuser.getUserAttributes((err, attributes) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve(attributes);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\tpublic verifiedContact(user: CognitoUser | any) {\n\t\tconst that = this;\n\t\treturn this.userAttributes(user).then(attributes => {\n\t\t\tconst attrs = that.attributesToObject(attributes);\n\t\t\tconst unverified = {};\n\t\t\tconst verified = {};\n\t\t\tif (attrs['email']) {\n\t\t\t\tif (attrs['email_verified']) {\n\t\t\t\t\tverified['email'] = attrs['email'];\n\t\t\t\t} else {\n\t\t\t\t\tunverified['email'] = attrs['email'];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (attrs['phone_number']) {\n\t\t\t\tif (attrs['phone_number_verified']) {\n\t\t\t\t\tverified['phone_number'] = attrs['phone_number'];\n\t\t\t\t} else {\n\t\t\t\t\tunverified['phone_number'] = attrs['phone_number'];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tverified,\n\t\t\t\tunverified,\n\t\t\t};\n\t\t});\n\t}\n\n\t/**\n\t * Get current authenticated user\n\t * @return - A promise resolves to current authenticated CognitoUser if success\n\t */\n\tpublic currentUserPoolUser(\n\t\tparams?: CurrentUserOpts\n\t): Promise<CognitoUser | any> {\n\t\tif (!this.userPool) {\n\t\t\treturn this.rejectNoUserPool();\n\t\t}\n\t\tconst that = this;\n\t\treturn new Promise((res, rej) => {\n\t\t\tthis._storageSync\n\t\t\t\t.then(() => {\n\t\t\t\t\tconst user = that.userPool.getCurrentUser();\n\t\t\t\t\tif (!user) {\n\t\t\t\t\t\tlogger.debug('Failed to get user from user pool');\n\t\t\t\t\t\trej('No current user');\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// refresh the session if the session expired.\n\t\t\t\t\tuser.getSession((err, session) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\tlogger.debug('Failed to get the user session', err);\n\t\t\t\t\t\t\trej(err);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// get user data from Cognito\n\t\t\t\t\t\tconst bypassCache = params ? params.bypassCache : false;\n\t\t\t\t\t\t// validate the token's scope fisrt before calling this function\n\t\t\t\t\t\tconst { scope = '' } = session.getAccessToken().decodePayload();\n\t\t\t\t\t\tif (scope.split(' ').includes(USER_ADMIN_SCOPE)) {\n\t\t\t\t\t\t\tuser.getUserData(\n\t\t\t\t\t\t\t\t(err, data) => {\n\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\tlogger.debug('getting user data failed', err);\n\t\t\t\t\t\t\t\t\t\t// Make sure the user is still valid\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\terr.message === 'User is disabled' ||\n\t\t\t\t\t\t\t\t\t\t\terr.message === 'User does not exist.'\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\trej(err);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t// the error may also be thrown when lack of permissions to get user info etc\n\t\t\t\t\t\t\t\t\t\t\t// in that case we just bypass the error\n\t\t\t\t\t\t\t\t\t\t\tres(user);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tconst preferredMFA = data.PreferredMfaSetting || 'NOMFA';\n\t\t\t\t\t\t\t\t\tconst attributeList = [];\n\n\t\t\t\t\t\t\t\t\tfor (let i = 0; i < data.UserAttributes.length; i++) {\n\t\t\t\t\t\t\t\t\t\tconst attribute = {\n\t\t\t\t\t\t\t\t\t\t\tName: data.UserAttributes[i].Name,\n\t\t\t\t\t\t\t\t\t\t\tValue: data.UserAttributes[i].Value,\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\tconst userAttribute = new CognitoUserAttribute(attribute);\n\t\t\t\t\t\t\t\t\t\tattributeList.push(userAttribute);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tconst attributes = that.attributesToObject(attributeList);\n\t\t\t\t\t\t\t\t\tObject.assign(user, { attributes, preferredMFA });\n\t\t\t\t\t\t\t\t\treturn res(user);\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{ bypassCache }\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t\t\t`Unable to get the user data because the ${USER_ADMIN_SCOPE} ` +\n\t\t\t\t\t\t\t\t\t`is not in the scopes of the access token`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\treturn res(user);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t})\n\t\t\t\t.catch(e => {\n\t\t\t\t\tlogger.debug('Failed to sync cache info into memory', e);\n\t\t\t\t\treturn rej(e);\n\t\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Get current authenticated user\n\t * @param {CurrentUserOpts} - options for getting the current user\n\t * @return - A promise resolves to current authenticated CognitoUser if success\n\t */\n\tpublic async currentAuthenticatedUser(\n\t\tparams?: CurrentUserOpts\n\t): Promise<CognitoUser | any> {\n\t\tlogger.debug('getting current authenticated user');\n\t\tlet federatedUser = null;\n\t\ttry {\n\t\t\tawait this._storageSync;\n\t\t} catch (e) {\n\t\t\tlogger.debug('Failed to sync cache info into memory', e);\n\t\t\tthrow e;\n\t\t}\n\n\t\ttry {\n\t\t\tfederatedUser = JSON.parse(\n\t\t\t\tthis._storage.getItem('aws-amplify-federatedInfo')\n\t\t\t).user;\n\t\t} catch (e) {\n\t\t\tlogger.debug('cannot load federated user from auth storage');\n\t\t}\n\n\t\tif (federatedUser) {\n\t\t\tthis.user = federatedUser;\n\t\t\tlogger.debug('get current authenticated federated user', this.user);\n\t\t\treturn this.user;\n\t\t} else {\n\t\t\tlogger.debug('get current authenticated userpool user');\n\t\t\tlet user = null;\n\t\t\ttry {\n\t\t\t\tuser = await this.currentUserPoolUser(params);\n\t\t\t} catch (e) {\n\t\t\t\tif (e === 'No userPool') {\n\t\t\t\t\tlogger.error(\n\t\t\t\t\t\t'Cannot get the current user because the user pool is missing. ' +\n\t\t\t\t\t\t\t'Please make sure the Auth module is configured with a valid Cognito User Pool ID'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tlogger.debug('The user is not authenticated by the error', e);\n\t\t\t\tthrow 'not authenticated';\n\t\t\t}\n\t\t\tthis.user = user;\n\t\t\treturn this.user;\n\t\t}\n\t}\n\n\t/**\n\t * Get current user's session\n\t * @return - A promise resolves to session object if success\n\t */\n\tpublic currentSession(): Promise<CognitoUserSession> {\n\t\tconst that = this;\n\t\tlogger.debug('Getting current session');\n\t\t// Purposely not calling the reject method here because we don't need a console error\n\t\tif (!this.userPool) {\n\t\t\treturn Promise.reject();\n\t\t}\n\n\t\treturn new Promise((res, rej) => {\n\t\t\tthat\n\t\t\t\t.currentUserPoolUser()\n\t\t\t\t.then(user => {\n\t\t\t\t\tthat\n\t\t\t\t\t\t.userSession(user)\n\t\t\t\t\t\t.then(session => {\n\t\t\t\t\t\t\tres(session);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch(e => {\n\t\t\t\t\t\t\tlogger.debug('Failed to get the current session', e);\n\t\t\t\t\t\t\trej(e);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t});\n\t\t\t\t})\n\t\t\t\t.catch(e => {\n\t\t\t\t\tlogger.debug('Failed to get the current user', e);\n\t\t\t\t\trej(e);\n\t\t\t\t\treturn;\n\t\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Get the corresponding user session\n\t * @param {Object} user - The CognitoUser object\n\t * @return - A promise resolves to the session\n\t */\n\tpublic userSession(user): Promise<CognitoUserSession> {\n\t\tif (!user) {\n\t\t\tlogger.debug('the user is null');\n\t\t\treturn this.rejectAuthError(AuthErrorTypes.NoUserSession);\n\t\t}\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tlogger.debug('Getting the session from this user:', user);\n\t\t\tuser.getSession((err, session) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tlogger.debug('Failed to get the session from user', user);\n\t\t\t\t\treject(err);\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tlogger.debug('Succeed to get the user session', session);\n\t\t\t\t\tresolve(session);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Get  authenticated credentials of current user.\n\t * @return - A promise resolves to be current user's credentials\n\t */\n\tpublic async currentUserCredentials(): Promise<ICredentials> {\n\t\tconst that = this;\n\t\tlogger.debug('Getting current user credentials');\n\n\t\ttry {\n\t\t\tawait this._storageSync;\n\t\t} catch (e) {\n\t\t\tlogger.debug('Failed to sync cache info into memory', e);\n\t\t\tthrow e;\n\t\t}\n\n\t\t// first to check whether there is federation info in the auth storage\n\t\tlet federatedInfo = null;\n\t\ttry {\n\t\t\tfederatedInfo = JSON.parse(\n\t\t\t\tthis._storage.getItem('aws-amplify-federatedInfo')\n\t\t\t);\n\t\t} catch (e) {\n\t\t\tlogger.debug('failed to get or parse item aws-amplify-federatedInfo', e);\n\t\t}\n\n\t\tif (federatedInfo) {\n\t\t\t// refresh the jwt token here if necessary\n\t\t\treturn Credentials.refreshFederatedToken(federatedInfo);\n\t\t} else {\n\t\t\treturn this.currentSession()\n\t\t\t\t.then(session => {\n\t\t\t\t\tlogger.debug('getting session success', session);\n\t\t\t\t\treturn Credentials.set(session, 'session');\n\t\t\t\t})\n\t\t\t\t.catch(error => {\n\t\t\t\t\tlogger.debug('getting session failed', error);\n\t\t\t\t\treturn Credentials.set(null, 'guest');\n\t\t\t\t});\n\t\t}\n\t}\n\n\tpublic currentCredentials(): Promise<ICredentials> {\n\t\tlogger.debug('getting current credntials');\n\t\treturn Credentials.get();\n\t}\n\n\t/**\n\t * Initiate an attribute confirmation request\n\t * @param {Object} user - The CognitoUser\n\t * @param {Object} attr - The attributes to be verified\n\t * @return - A promise resolves to callback data if success\n\t */\n\tpublic verifyUserAttribute(\n\t\tuser: CognitoUser | any,\n\t\tattr: string,\n\t\tclientMetadata: ClientMetaData = this._config.clientMetadata\n\t): Promise<void> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tuser.getAttributeVerificationCode(attr, {\n\t\t\t\tonSuccess() {\n\t\t\t\t\treturn resolve();\n\t\t\t\t},\n\t\t\t\tonFailure(err) {\n\t\t\t\t\treturn reject(err);\n\t\t\t\t},\n\t\t\t\tclientMetadata,\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Confirm an attribute using a confirmation code\n\t * @param {Object} user - The CognitoUser\n\t * @param {Object} attr - The attribute to be verified\n\t * @param {String} code - The confirmation code\n\t * @return - A promise resolves to callback data if success\n\t */\n\tpublic verifyUserAttributeSubmit(\n\t\tuser: CognitoUser | any,\n\t\tattr: string,\n\t\tcode: string\n\t): Promise<string> {\n\t\tif (!code) {\n\t\t\treturn this.rejectAuthError(AuthErrorTypes.EmptyCode);\n\t\t}\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tuser.verifyAttribute(attr, code, {\n\t\t\t\tonSuccess(data) {\n\t\t\t\t\tresolve(data);\n\t\t\t\t\treturn;\n\t\t\t\t},\n\t\t\t\tonFailure(err) {\n\t\t\t\t\treject(err);\n\t\t\t\t\treturn;\n\t\t\t\t},\n\t\t\t});\n\t\t});\n\t}\n\n\tpublic verifyCurrentUserAttribute(attr: string): Promise<void> {\n\t\tconst that = this;\n\t\treturn that\n\t\t\t.currentUserPoolUser()\n\t\t\t.then(user => that.verifyUserAttribute(user, attr));\n\t}\n\n\t/**\n\t * Confirm current user's attribute using a confirmation code\n\t * @param {Object} attr - The attribute to be verified\n\t * @param {String} code - The confirmation code\n\t * @return - A promise resolves to callback data if success\n\t */\n\tverifyCurrentUserAttributeSubmit(\n\t\tattr: string,\n\t\tcode: string\n\t): Promise<string> {\n\t\tconst that = this;\n\t\treturn that\n\t\t\t.currentUserPoolUser()\n\t\t\t.then(user => that.verifyUserAttributeSubmit(user, attr, code));\n\t}\n\n\tprivate async cognitoIdentitySignOut(\n\t\topts: SignOutOpts,\n\t\tuser: CognitoUser | any\n\t) {\n\t\ttry {\n\t\t\tawait this._storageSync;\n\t\t} catch (e) {\n\t\t\tlogger.debug('Failed to sync cache info into memory', e);\n\t\t\tthrow e;\n\t\t}\n\n\t\tconst isSignedInHostedUI =\n\t\t\tthis._oAuthHandler &&\n\t\t\tthis._storage.getItem('amplify-signin-with-hostedUI') === 'true';\n\n\t\treturn new Promise((res, rej) => {\n\t\t\tif (opts && opts.global) {\n\t\t\t\tlogger.debug('user global sign out', user);\n\t\t\t\t// in order to use global signout\n\t\t\t\t// we must validate the user as an authenticated user by using getSession\n\t\t\t\tuser.getSession((err, result) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tlogger.debug('failed to get the user session', err);\n\t\t\t\t\t\treturn rej(err);\n\t\t\t\t\t}\n\t\t\t\t\tuser.globalSignOut({\n\t\t\t\t\t\tonSuccess: data => {\n\t\t\t\t\t\t\tlogger.debug('global sign out success');\n\t\t\t\t\t\t\tif (isSignedInHostedUI) {\n\t\t\t\t\t\t\t\treturn res(this._oAuthHandler.signOut());\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn res();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tonFailure: err => {\n\t\t\t\t\t\t\tlogger.debug('global sign out failed', err);\n\t\t\t\t\t\t\treturn rej(err);\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tlogger.debug('user sign out', user);\n\t\t\t\tuser.signOut();\n\t\t\t\tif (isSignedInHostedUI) {\n\t\t\t\t\treturn res(this._oAuthHandler.signOut());\n\t\t\t\t} else {\n\t\t\t\t\treturn res();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Sign out method\n\t * @\n\t * @return - A promise resolved if success\n\t */\n\tpublic async signOut(opts?: SignOutOpts): Promise<any> {\n\t\ttry {\n\t\t\tawait this.cleanCachedItems();\n\t\t} catch (e) {\n\t\t\tlogger.debug('failed to clear cached items');\n\t\t}\n\n\t\tif (this.userPool) {\n\t\t\tconst user = this.userPool.getCurrentUser();\n\t\t\tif (user) {\n\t\t\t\tawait this.cognitoIdentitySignOut(opts, user);\n\t\t\t} else {\n\t\t\t\tlogger.debug('no current Cognito user');\n\t\t\t}\n\t\t} else {\n\t\t\tlogger.debug('no Congito User pool');\n\t\t}\n\n\t\t/**\n\t\t * Note for future refactor - no reliable way to get username with\n\t\t * Cognito User Pools vs Identity when federating with Social Providers\n\t\t * This is why we need a well structured session object that can be inspected\n\t\t * and information passed back in the message below for Hub dispatch\n\t\t */\n\t\tdispatchAuthEvent('signOut', this.user, `A user has been signed out`);\n\t\tthis.user = null;\n\t}\n\n\tprivate async cleanCachedItems() {\n\t\t// clear cognito cached item\n\t\tawait Credentials.clear();\n\t}\n\n\t/**\n\t * Change a password for an authenticated user\n\t * @param {Object} user - The CognitoUser object\n\t * @param {String} oldPassword - the current password\n\t * @param {String} newPassword - the requested new password\n\t * @return - A promise resolves if success\n\t */\n\tpublic changePassword(\n\t\tuser: CognitoUser | any,\n\t\toldPassword: string,\n\t\tnewPassword: string,\n\t\tclientMetadata: ClientMetaData = this._config.clientMetadata\n\t): Promise<'SUCCESS'> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.userSession(user).then(session => {\n\t\t\t\tuser.changePassword(\n\t\t\t\t\toldPassword,\n\t\t\t\t\tnewPassword,\n\t\t\t\t\t(err, data) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\tlogger.debug('change password failure', err);\n\t\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn resolve(data);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tclientMetadata\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Initiate a forgot password request\n\t * @param {String} username - the username to change password\n\t * @return - A promise resolves if success\n\t */\n\tpublic forgotPassword(\n\t\tusername: string,\n\t\tclientMetadata: ClientMetaData = this._config.clientMetadata\n\t): Promise<any> {\n\t\tif (!this.userPool) {\n\t\t\treturn this.rejectNoUserPool();\n\t\t}\n\t\tif (!username) {\n\t\t\treturn this.rejectAuthError(AuthErrorTypes.EmptyUsername);\n\t\t}\n\n\t\tconst user = this.createCognitoUser(username);\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tuser.forgotPassword(\n\t\t\t\t{\n\t\t\t\t\tonSuccess: () => {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t},\n\t\t\t\t\tonFailure: err => {\n\t\t\t\t\t\tlogger.debug('forgot password failure', err);\n\t\t\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t\t\t'forgotPassword_failure',\n\t\t\t\t\t\t\terr,\n\t\t\t\t\t\t\t`${username} forgotPassword failed`\n\t\t\t\t\t\t);\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t},\n\t\t\t\t\tinputVerificationCode: data => {\n\t\t\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t\t\t'forgotPassword',\n\t\t\t\t\t\t\tuser,\n\t\t\t\t\t\t\t`${username} has initiated forgot password flow`\n\t\t\t\t\t\t);\n\t\t\t\t\t\tresolve(data);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tclientMetadata\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * Confirm a new password using a confirmation Code\n\t * @param {String} username - The username\n\t * @param {String} code - The confirmation code\n\t * @param {String} password - The new password\n\t * @return - A promise that resolves if success\n\t */\n\tpublic forgotPasswordSubmit(\n\t\tusername: string,\n\t\tcode: string,\n\t\tpassword: string,\n\t\tclientMetadata: ClientMetaData = this._config.clientMetadata\n\t): Promise<void> {\n\t\tif (!this.userPool) {\n\t\t\treturn this.rejectNoUserPool();\n\t\t}\n\t\tif (!username) {\n\t\t\treturn this.rejectAuthError(AuthErrorTypes.EmptyUsername);\n\t\t}\n\t\tif (!code) {\n\t\t\treturn this.rejectAuthError(AuthErrorTypes.EmptyCode);\n\t\t}\n\t\tif (!password) {\n\t\t\treturn this.rejectAuthError(AuthErrorTypes.EmptyPassword);\n\t\t}\n\n\t\tconst user = this.createCognitoUser(username);\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tuser.confirmPassword(\n\t\t\t\tcode,\n\t\t\t\tpassword,\n\t\t\t\t{\n\t\t\t\t\tonSuccess: () => {\n\t\t\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t\t\t'forgotPasswordSubmit',\n\t\t\t\t\t\t\tuser,\n\t\t\t\t\t\t\t`${username} forgotPasswordSubmit successful`\n\t\t\t\t\t\t);\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t},\n\t\t\t\t\tonFailure: err => {\n\t\t\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t\t\t'forgotPasswordSubmit_failure',\n\t\t\t\t\t\t\terr,\n\t\t\t\t\t\t\t`${username} forgotPasswordSubmit failed`\n\t\t\t\t\t\t);\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tclientMetadata\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * Get user information\n\t * @async\n\t * @return {Object }- current User's information\n\t */\n\tpublic async currentUserInfo() {\n\t\tconst source = Credentials.getCredSource();\n\n\t\tif (!source || source === 'aws' || source === 'userPool') {\n\t\t\tconst user = await this.currentUserPoolUser().catch(err =>\n\t\t\t\tlogger.debug(err)\n\t\t\t);\n\t\t\tif (!user) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst attributes = await this.userAttributes(user);\n\t\t\t\tconst userAttrs: object = this.attributesToObject(attributes);\n\t\t\t\tlet credentials = null;\n\t\t\t\ttry {\n\t\t\t\t\tcredentials = await this.currentCredentials();\n\t\t\t\t} catch (e) {\n\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t'Failed to retrieve credentials while getting current user info',\n\t\t\t\t\t\te\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst info = {\n\t\t\t\t\tid: credentials ? credentials.identityId : undefined,\n\t\t\t\t\tusername: user.getUsername(),\n\t\t\t\t\tattributes: userAttrs,\n\t\t\t\t};\n\t\t\t\treturn info;\n\t\t\t} catch (err) {\n\t\t\t\tlogger.debug('currentUserInfo error', err);\n\t\t\t\treturn {};\n\t\t\t}\n\t\t}\n\n\t\tif (source === 'federated') {\n\t\t\tconst user = this.user;\n\t\t\treturn user ? user : {};\n\t\t}\n\t}\n\n\tpublic async federatedSignIn(\n\t\toptions?: FederatedSignInOptions\n\t): Promise<ICredentials>;\n\tpublic async federatedSignIn(\n\t\tprovider: LegacyProvider,\n\t\tresponse: FederatedResponse,\n\t\tuser: FederatedUser\n\t): Promise<ICredentials>;\n\tpublic async federatedSignIn(\n\t\toptions?: FederatedSignInOptionsCustom\n\t): Promise<ICredentials>;\n\tpublic async federatedSignIn(\n\t\tproviderOrOptions:\n\t\t\t| LegacyProvider\n\t\t\t| FederatedSignInOptions\n\t\t\t| FederatedSignInOptionsCustom,\n\t\tresponse?: FederatedResponse,\n\t\tuser?: FederatedUser\n\t): Promise<ICredentials> {\n\t\tif (!this._config.identityPoolId && !this._config.userPoolId) {\n\t\t\tthrow new Error(\n\t\t\t\t`Federation requires either a User Pool or Identity Pool in config`\n\t\t\t);\n\t\t}\n\n\t\t// Ensure backwards compatability\n\t\tif (typeof providerOrOptions === 'undefined') {\n\t\t\tif (this._config.identityPoolId && !this._config.userPoolId) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Federation with Identity Pools requires tokens passed as arguments`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tif (\n\t\t\tisFederatedSignInOptions(providerOrOptions) ||\n\t\t\tisFederatedSignInOptionsCustom(providerOrOptions) ||\n\t\t\ttypeof providerOrOptions === 'undefined'\n\t\t) {\n\t\t\tconst options = providerOrOptions || {\n\t\t\t\tprovider: CognitoHostedUIIdentityProvider.Cognito,\n\t\t\t};\n\t\t\tconst provider = isFederatedSignInOptions(options)\n\t\t\t\t? options.provider\n\t\t\t\t: (options as FederatedSignInOptionsCustom).customProvider;\n\n\t\t\tconst customState = isFederatedSignInOptions(options)\n\t\t\t\t? options.customState\n\t\t\t\t: (options as FederatedSignInOptionsCustom).customState;\n\n\t\t\tif (this._config.userPoolId) {\n\t\t\t\tconst client_id = isCognitoHostedOpts(this._config.oauth)\n\t\t\t\t\t? this._config.userPoolWebClientId\n\t\t\t\t\t: this._config.oauth.clientID;\n\t\t\t\t/*Note: Invenstigate automatically adding trailing slash */\n\t\t\t\tconst redirect_uri = isCognitoHostedOpts(this._config.oauth)\n\t\t\t\t\t? this._config.oauth.redirectSignIn\n\t\t\t\t\t: this._config.oauth.redirectUri;\n\n\t\t\t\tthis._oAuthHandler.oauthSignIn(\n\t\t\t\t\tthis._config.oauth.responseType,\n\t\t\t\t\tthis._config.oauth.domain,\n\t\t\t\t\tredirect_uri,\n\t\t\t\t\tclient_id,\n\t\t\t\t\tprovider,\n\t\t\t\t\tcustomState\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tconst provider = providerOrOptions;\n\t\t\t// To check if the user is already logged in\n\t\t\ttry {\n\t\t\t\tconst loggedInUser = JSON.stringify(\n\t\t\t\t\tJSON.parse(this._storage.getItem('aws-amplify-federatedInfo')).user\n\t\t\t\t);\n\t\t\t\tif (loggedInUser) {\n\t\t\t\t\tlogger.warn(`There is already a signed in user: ${loggedInUser} in your app.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tYou should not call Auth.federatedSignIn method again as it may cause unexpected behavior.`);\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\n\t\t\tconst { token, identity_id, expires_at } = response;\n\t\t\t// Because Credentials.set would update the user info with identity id\n\t\t\t// So we need to retrieve the user again.\n\t\t\tconst credentials = await Credentials.set(\n\t\t\t\t{ provider, token, identity_id, user, expires_at },\n\t\t\t\t'federation'\n\t\t\t);\n\t\t\tconst currentUser = await this.currentAuthenticatedUser();\n\t\t\tdispatchAuthEvent(\n\t\t\t\t'signIn',\n\t\t\t\tcurrentUser,\n\t\t\t\t`A user ${currentUser.username} has been signed in`\n\t\t\t);\n\t\t\tlogger.debug('federated sign in credentials', credentials);\n\t\t\treturn credentials;\n\t\t}\n\t}\n\n\t/**\n\t * Used to complete the OAuth flow with or without the Cognito Hosted UI\n\t * @param {String} URL - optional parameter for customers to pass in the response URL\n\t */\n\tprivate async _handleAuthResponse(URL?: string) {\n\t\tif (!this._config.userPoolId) {\n\t\t\tthrow new Error(`OAuth responses require a User Pool defined in config`);\n\t\t}\n\n\t\tdispatchAuthEvent(\n\t\t\t'parsingCallbackUrl',\n\t\t\t{ url: URL },\n\t\t\t`The callback url is being parsed`\n\t\t);\n\n\t\tconst currentUrl =\n\t\t\tURL || (JS.browserOrNode().isBrowser ? window.location.href : '');\n\n\t\tconst hasCodeOrError = !!(parse(currentUrl).query || '')\n\t\t\t.split('&')\n\t\t\t.map(entry => entry.split('='))\n\t\t\t.find(([k]) => k === 'code' || k === 'error');\n\n\t\tconst hasTokenOrError = !!(parse(currentUrl).hash || '#')\n\t\t\t.substr(1)\n\t\t\t.split('&')\n\t\t\t.map(entry => entry.split('='))\n\t\t\t.find(([k]) => k === 'access_token' || k === 'error');\n\n\t\tif (hasCodeOrError || hasTokenOrError) {\n\t\t\ttry {\n\t\t\t\tconst {\n\t\t\t\t\taccessToken,\n\t\t\t\t\tidToken,\n\t\t\t\t\trefreshToken,\n\t\t\t\t\tstate,\n\t\t\t\t} = await this._oAuthHandler.handleAuthResponse(currentUrl);\n\t\t\t\tconst session = new CognitoUserSession({\n\t\t\t\t\tIdToken: new CognitoIdToken({ IdToken: idToken }),\n\t\t\t\t\tRefreshToken: new CognitoRefreshToken({ RefreshToken: refreshToken }),\n\t\t\t\t\tAccessToken: new CognitoAccessToken({ AccessToken: accessToken }),\n\t\t\t\t});\n\n\t\t\t\tlet credentials;\n\t\t\t\t// Get AWS Credentials & store if Identity Pool is defined\n\t\t\t\tif (this._config.identityPoolId) {\n\t\t\t\t\tcredentials = await Credentials.set(session, 'session');\n\t\t\t\t\tlogger.debug('AWS credentials', credentials);\n\t\t\t\t}\n\n\t\t\t\t/* \n                Prior to the request we do sign the custom state along with the state we set. This check will verify\n                if there is a dash indicated when setting custom state from the request. If a dash is contained\n                then there is custom state present on the state string.\n                */\n\t\t\t\tconst isCustomStateIncluded = /-/.test(state);\n\n\t\t\t\t/*The following is to create a user for the Cognito Identity SDK to store the tokens\n                  When we remove this SDK later that logic will have to be centralized in our new version*/\n\t\t\t\t//#region\n\t\t\t\tconst currentUser = this.createCognitoUser(\n\t\t\t\t\tsession.getIdToken().decodePayload()['cognito:username']\n\t\t\t\t);\n\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t'signIn',\n\t\t\t\t\tcurrentUser,\n\t\t\t\t\t`A user ${currentUser.getUsername()} has been signed in`\n\t\t\t\t);\n\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t'cognitoHostedUI',\n\t\t\t\t\tcurrentUser,\n\t\t\t\t\t`A user ${currentUser.getUsername()} has been signed in via Cognito Hosted UI`\n\t\t\t\t);\n\n\t\t\t\tif (isCustomStateIncluded) {\n\t\t\t\t\tconst [, customState] = state.split('-');\n\n\t\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t\t'customOAuthState',\n\t\t\t\t\t\tcustomState,\n\t\t\t\t\t\t`State for user ${currentUser.getUsername()}`\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// This calls cacheTokens() in Cognito SDK\n\t\t\t\tcurrentUser.setSignInUserSession(session);\n\t\t\t\t//#endregion\n\n\t\t\t\tif (window && typeof window.history !== 'undefined') {\n\t\t\t\t\twindow.history.replaceState(\n\t\t\t\t\t\t{},\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t(this._config.oauth as AwsCognitoOAuthOpts).redirectSignIn\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn credentials;\n\t\t\t} catch (err) {\n\t\t\t\tlogger.debug('Error in cognito hosted auth response', err);\n\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t'signIn_failure',\n\t\t\t\t\terr,\n\t\t\t\t\t`The OAuth response flow failed`\n\t\t\t\t);\n\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t'cognitoHostedUI_failure',\n\t\t\t\t\terr,\n\t\t\t\t\t`A failure occurred when returning to the Cognito Hosted UI`\n\t\t\t\t);\n\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t'customState_failure',\n\t\t\t\t\terr,\n\t\t\t\t\t`A failure occurred when returning state`\n\t\t\t\t);\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Compact version of credentials\n\t * @param {Object} credentials\n\t * @return {Object} - Credentials\n\t */\n\tpublic essentialCredentials(credentials): ICredentials {\n\t\treturn {\n\t\t\taccessKeyId: credentials.accessKeyId,\n\t\t\tsessionToken: credentials.sessionToken,\n\t\t\tsecretAccessKey: credentials.secretAccessKey,\n\t\t\tidentityId: credentials.identityId,\n\t\t\tauthenticated: credentials.authenticated,\n\t\t};\n\t}\n\n\tprivate attributesToObject(attributes) {\n\t\tconst obj = {};\n\t\tif (attributes) {\n\t\t\tattributes.map(attribute => {\n\t\t\t\tif (attribute.Value === 'true') {\n\t\t\t\t\tobj[attribute.Name] = true;\n\t\t\t\t} else if (attribute.Value === 'false') {\n\t\t\t\t\tobj[attribute.Name] = false;\n\t\t\t\t} else {\n\t\t\t\t\tobj[attribute.Name] = attribute.Value;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn obj;\n\t}\n\n\tprivate createCognitoUser(username: string): CognitoUser {\n\t\tconst userData: ICognitoUserData = {\n\t\t\tUsername: username,\n\t\t\tPool: this.userPool,\n\t\t};\n\t\tuserData.Storage = this._storage;\n\n\t\tconst { authenticationFlowType } = this._config;\n\n\t\tconst user = new CognitoUser(userData);\n\t\tif (authenticationFlowType) {\n\t\t\tuser.setAuthenticationFlowType(authenticationFlowType);\n\t\t}\n\t\treturn user;\n\t}\n\n\tprivate _isValidAuthStorage(obj) {\n\t\t// We need to check if the obj has the functions of Storage\n\t\treturn (\n\t\t\t!!obj &&\n\t\t\ttypeof obj.getItem === 'function' &&\n\t\t\ttypeof obj.setItem === 'function' &&\n\t\t\ttypeof obj.removeItem === 'function' &&\n\t\t\ttypeof obj.clear === 'function'\n\t\t);\n\t}\n\n\tprivate noUserPoolErrorHandler(config: AuthOptions): AuthErrorTypes {\n\t\tif (config) {\n\t\t\tif (!config.userPoolId || !config.identityPoolId) {\n\t\t\t\treturn AuthErrorTypes.MissingAuthConfig;\n\t\t\t}\n\t\t}\n\t\treturn AuthErrorTypes.NoConfig;\n\t}\n\n\tprivate rejectAuthError(type: AuthErrorTypes): Promise<never> {\n\t\treturn Promise.reject(new AuthError(type));\n\t}\n\n\tprivate rejectNoUserPool(): Promise<never> {\n\t\tconst type = this.noUserPoolErrorHandler(this._config);\n\t\treturn Promise.reject(new NoUserPoolError(type));\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}